// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(rgb_libFFI)
import rgb_libFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_rgblibffi_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_rgblibffi_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: nil)
}

private func rustCallWithError<T>(
    _ errorHandler: @escaping (RustBuffer) throws -> Error,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate class UniffiHandleMap<T> {
    private var map: [UInt64: T] = [:]
    private let lock = NSLock()
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterInt32: FfiConverterPrimitive {
    typealias FfiType = Int32
    typealias SwiftType = Int32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int32, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterFloat: FfiConverterPrimitive {
    typealias FfiType = Float
    typealias SwiftType = Float

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Float {
        return try lift(readFloat(&buf))
    }

    public static func write(_ value: Float, into buf: inout [UInt8]) {
        writeFloat(&buf, lower(value))
    }
}

fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}




public protocol InvoiceProtocol : AnyObject {
    
    func invoiceData()  -> InvoiceData
    
    func invoiceString()  -> String
    
}

open class Invoice:
    InvoiceProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_rgblibffi_fn_clone_invoice(self.pointer, $0) }
    }
public convenience init(invoiceString: String)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgblibffi_fn_constructor_invoice_new(
        FfiConverterString.lower(invoiceString),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_rgblibffi_fn_free_invoice(pointer, $0) }
    }

    
public static func fromInvoiceData(invoiceData: InvoiceData)throws  -> Invoice {
    return try  FfiConverterTypeInvoice.lift(try rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgblibffi_fn_constructor_invoice_from_invoice_data(
        FfiConverterTypeInvoiceData.lower(invoiceData),$0
    )
})
}
    

    
open func invoiceData() -> InvoiceData {
    return try!  FfiConverterTypeInvoiceData.lift(try! rustCall() {
    uniffi_rgblibffi_fn_method_invoice_invoice_data(self.uniffiClonePointer(),$0
    )
})
}
    
open func invoiceString() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_rgblibffi_fn_method_invoice_invoice_string(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeInvoice: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Invoice

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Invoice {
        return Invoice(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Invoice) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Invoice {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Invoice, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeInvoice_lift(_ pointer: UnsafeMutableRawPointer) throws -> Invoice {
    return try FfiConverterTypeInvoice.lift(pointer)
}

public func FfiConverterTypeInvoice_lower(_ value: Invoice) -> UnsafeMutableRawPointer {
    return FfiConverterTypeInvoice.lower(value)
}




public protocol RecipientInfoProtocol : AnyObject {
    
}

open class RecipientInfo:
    RecipientInfoProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_rgblibffi_fn_clone_recipientinfo(self.pointer, $0) }
    }
public convenience init(recipientId: String)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgblibffi_fn_constructor_recipientinfo_new(
        FfiConverterString.lower(recipientId),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_rgblibffi_fn_free_recipientinfo(pointer, $0) }
    }

    

    

}

public struct FfiConverterTypeRecipientInfo: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RecipientInfo

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RecipientInfo {
        return RecipientInfo(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RecipientInfo) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RecipientInfo {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RecipientInfo, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeRecipientInfo_lift(_ pointer: UnsafeMutableRawPointer) throws -> RecipientInfo {
    return try FfiConverterTypeRecipientInfo.lift(pointer)
}

public func FfiConverterTypeRecipientInfo_lower(_ value: RecipientInfo) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRecipientInfo.lower(value)
}




public protocol TransportEndpointProtocol : AnyObject {
    
    func transportType()  -> TransportType
    
}

open class TransportEndpoint:
    TransportEndpointProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_rgblibffi_fn_clone_transportendpoint(self.pointer, $0) }
    }
public convenience init(transportEndpoint: String)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgblibffi_fn_constructor_transportendpoint_new(
        FfiConverterString.lower(transportEndpoint),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_rgblibffi_fn_free_transportendpoint(pointer, $0) }
    }

    

    
open func transportType() -> TransportType {
    return try!  FfiConverterTypeTransportType.lift(try! rustCall() {
    uniffi_rgblibffi_fn_method_transportendpoint_transport_type(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeTransportEndpoint: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TransportEndpoint

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TransportEndpoint {
        return TransportEndpoint(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TransportEndpoint) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransportEndpoint {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TransportEndpoint, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeTransportEndpoint_lift(_ pointer: UnsafeMutableRawPointer) throws -> TransportEndpoint {
    return try FfiConverterTypeTransportEndpoint.lift(pointer)
}

public func FfiConverterTypeTransportEndpoint_lower(_ value: TransportEndpoint) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTransportEndpoint.lower(value)
}




public protocol WalletProtocol : AnyObject {
    
    func backup(backupPath: String, password: String) throws 
    
    func backupInfo() throws  -> Bool
    
    func blindReceive(assetId: String?, amount: UInt64?, durationSeconds: UInt32?, transportEndpoints: [String], minConfirmations: UInt8) throws  -> ReceiveData
    
    func createUtxos(online: Online, upTo: Bool, num: UInt8?, size: UInt32?, feeRate: Float) throws  -> UInt8
    
    func createUtxosBegin(online: Online, upTo: Bool, num: UInt8?, size: UInt32?, feeRate: Float) throws  -> String
    
    func createUtxosEnd(online: Online, signedPsbt: String) throws  -> UInt8
    
    func deleteTransfers(batchTransferIdx: Int32?, noAssetOnly: Bool) throws  -> Bool
    
    func drainTo(online: Online, address: String, destroyAssets: Bool, feeRate: Float) throws  -> String
    
    func drainToBegin(online: Online, address: String, destroyAssets: Bool, feeRate: Float) throws  -> String
    
    func drainToEnd(online: Online, signedPsbt: String) throws  -> String
    
    func failTransfers(online: Online, batchTransferIdx: Int32?, noAssetOnly: Bool) throws  -> Bool
    
    func getAddress() throws  -> String
    
    func getAssetBalance(assetId: String) throws  -> Balance
    
    func getAssetMetadata(assetId: String) throws  -> Metadata
    
    func getBtcBalance(online: Online) throws  -> BtcBalance
    
    func goOnline(skipConsistencyCheck: Bool, indexerUrl: String) throws  -> Online
    
    func issueAssetCfa(online: Online, name: String, details: String?, precision: UInt8, amounts: [UInt64], filePath: String?) throws  -> AssetCfa
    
    func issueAssetNia(online: Online, ticker: String, name: String, precision: UInt8, amounts: [UInt64]) throws  -> AssetNia
    
    func issueAssetUda(online: Online, ticker: String, name: String, details: String?, precision: UInt8, mediaFilePath: String?, attachmentsFilePaths: [String]) throws  -> AssetUda
    
    func listAssets(filterAssetSchemas: [AssetSchema]) throws  -> Assets
    
    func listTransactions(online: Online?) throws  -> [Transaction]
    
    func listTransfers(assetId: String?) throws  -> [Transfer]
    
    func listUnspents(online: Online?, settledOnly: Bool) throws  -> [Unspent]
    
    func refresh(online: Online, assetId: String?, filter: [RefreshFilter]) throws  -> [Int32: RefreshedTransfer]
    
    func send(online: Online, recipientMap: [String: [Recipient]], donation: Bool, feeRate: Float, minConfirmations: UInt8) throws  -> SendResult
    
    func sendBegin(online: Online, recipientMap: [String: [Recipient]], donation: Bool, feeRate: Float, minConfirmations: UInt8) throws  -> String
    
    func sendBtc(online: Online, address: String, amount: UInt64, feeRate: Float) throws  -> String
    
    func sendBtcBegin(online: Online, address: String, amount: UInt64, feeRate: Float) throws  -> String
    
    func sendBtcEnd(online: Online, signedPsbt: String) throws  -> String
    
    func sendEnd(online: Online, signedPsbt: String) throws  -> SendResult
    
    func signPsbt(unsignedPsbt: String) throws  -> String
    
    func witnessReceive(assetId: String?, amount: UInt64?, durationSeconds: UInt32?, transportEndpoints: [String], minConfirmations: UInt8) throws  -> ReceiveData
    
}

open class Wallet:
    WalletProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_rgblibffi_fn_clone_wallet(self.pointer, $0) }
    }
public convenience init(walletData: WalletData)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgblibffi_fn_constructor_wallet_new(
        FfiConverterTypeWalletData.lower(walletData),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_rgblibffi_fn_free_wallet(pointer, $0) }
    }

    

    
open func backup(backupPath: String, password: String)throws  {try rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgblibffi_fn_method_wallet_backup(self.uniffiClonePointer(),
        FfiConverterString.lower(backupPath),
        FfiConverterString.lower(password),$0
    )
}
}
    
open func backupInfo()throws  -> Bool {
    return try  FfiConverterBool.lift(try rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgblibffi_fn_method_wallet_backup_info(self.uniffiClonePointer(),$0
    )
})
}
    
open func blindReceive(assetId: String?, amount: UInt64?, durationSeconds: UInt32?, transportEndpoints: [String], minConfirmations: UInt8)throws  -> ReceiveData {
    return try  FfiConverterTypeReceiveData.lift(try rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgblibffi_fn_method_wallet_blind_receive(self.uniffiClonePointer(),
        FfiConverterOptionString.lower(assetId),
        FfiConverterOptionUInt64.lower(amount),
        FfiConverterOptionUInt32.lower(durationSeconds),
        FfiConverterSequenceString.lower(transportEndpoints),
        FfiConverterUInt8.lower(minConfirmations),$0
    )
})
}
    
open func createUtxos(online: Online, upTo: Bool, num: UInt8?, size: UInt32?, feeRate: Float)throws  -> UInt8 {
    return try  FfiConverterUInt8.lift(try rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgblibffi_fn_method_wallet_create_utxos(self.uniffiClonePointer(),
        FfiConverterTypeOnline.lower(online),
        FfiConverterBool.lower(upTo),
        FfiConverterOptionUInt8.lower(num),
        FfiConverterOptionUInt32.lower(size),
        FfiConverterFloat.lower(feeRate),$0
    )
})
}
    
open func createUtxosBegin(online: Online, upTo: Bool, num: UInt8?, size: UInt32?, feeRate: Float)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgblibffi_fn_method_wallet_create_utxos_begin(self.uniffiClonePointer(),
        FfiConverterTypeOnline.lower(online),
        FfiConverterBool.lower(upTo),
        FfiConverterOptionUInt8.lower(num),
        FfiConverterOptionUInt32.lower(size),
        FfiConverterFloat.lower(feeRate),$0
    )
})
}
    
open func createUtxosEnd(online: Online, signedPsbt: String)throws  -> UInt8 {
    return try  FfiConverterUInt8.lift(try rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgblibffi_fn_method_wallet_create_utxos_end(self.uniffiClonePointer(),
        FfiConverterTypeOnline.lower(online),
        FfiConverterString.lower(signedPsbt),$0
    )
})
}
    
open func deleteTransfers(batchTransferIdx: Int32?, noAssetOnly: Bool)throws  -> Bool {
    return try  FfiConverterBool.lift(try rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgblibffi_fn_method_wallet_delete_transfers(self.uniffiClonePointer(),
        FfiConverterOptionInt32.lower(batchTransferIdx),
        FfiConverterBool.lower(noAssetOnly),$0
    )
})
}
    
open func drainTo(online: Online, address: String, destroyAssets: Bool, feeRate: Float)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgblibffi_fn_method_wallet_drain_to(self.uniffiClonePointer(),
        FfiConverterTypeOnline.lower(online),
        FfiConverterString.lower(address),
        FfiConverterBool.lower(destroyAssets),
        FfiConverterFloat.lower(feeRate),$0
    )
})
}
    
open func drainToBegin(online: Online, address: String, destroyAssets: Bool, feeRate: Float)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgblibffi_fn_method_wallet_drain_to_begin(self.uniffiClonePointer(),
        FfiConverterTypeOnline.lower(online),
        FfiConverterString.lower(address),
        FfiConverterBool.lower(destroyAssets),
        FfiConverterFloat.lower(feeRate),$0
    )
})
}
    
open func drainToEnd(online: Online, signedPsbt: String)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgblibffi_fn_method_wallet_drain_to_end(self.uniffiClonePointer(),
        FfiConverterTypeOnline.lower(online),
        FfiConverterString.lower(signedPsbt),$0
    )
})
}
    
open func failTransfers(online: Online, batchTransferIdx: Int32?, noAssetOnly: Bool)throws  -> Bool {
    return try  FfiConverterBool.lift(try rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgblibffi_fn_method_wallet_fail_transfers(self.uniffiClonePointer(),
        FfiConverterTypeOnline.lower(online),
        FfiConverterOptionInt32.lower(batchTransferIdx),
        FfiConverterBool.lower(noAssetOnly),$0
    )
})
}
    
open func getAddress()throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgblibffi_fn_method_wallet_get_address(self.uniffiClonePointer(),$0
    )
})
}
    
open func getAssetBalance(assetId: String)throws  -> Balance {
    return try  FfiConverterTypeBalance.lift(try rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgblibffi_fn_method_wallet_get_asset_balance(self.uniffiClonePointer(),
        FfiConverterString.lower(assetId),$0
    )
})
}
    
open func getAssetMetadata(assetId: String)throws  -> Metadata {
    return try  FfiConverterTypeMetadata.lift(try rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgblibffi_fn_method_wallet_get_asset_metadata(self.uniffiClonePointer(),
        FfiConverterString.lower(assetId),$0
    )
})
}
    
open func getBtcBalance(online: Online)throws  -> BtcBalance {
    return try  FfiConverterTypeBtcBalance.lift(try rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgblibffi_fn_method_wallet_get_btc_balance(self.uniffiClonePointer(),
        FfiConverterTypeOnline.lower(online),$0
    )
})
}
    
open func goOnline(skipConsistencyCheck: Bool, indexerUrl: String)throws  -> Online {
    return try  FfiConverterTypeOnline.lift(try rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgblibffi_fn_method_wallet_go_online(self.uniffiClonePointer(),
        FfiConverterBool.lower(skipConsistencyCheck),
        FfiConverterString.lower(indexerUrl),$0
    )
})
}
    
open func issueAssetCfa(online: Online, name: String, details: String?, precision: UInt8, amounts: [UInt64], filePath: String?)throws  -> AssetCfa {
    return try  FfiConverterTypeAssetCFA.lift(try rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgblibffi_fn_method_wallet_issue_asset_cfa(self.uniffiClonePointer(),
        FfiConverterTypeOnline.lower(online),
        FfiConverterString.lower(name),
        FfiConverterOptionString.lower(details),
        FfiConverterUInt8.lower(precision),
        FfiConverterSequenceUInt64.lower(amounts),
        FfiConverterOptionString.lower(filePath),$0
    )
})
}
    
open func issueAssetNia(online: Online, ticker: String, name: String, precision: UInt8, amounts: [UInt64])throws  -> AssetNia {
    return try  FfiConverterTypeAssetNIA.lift(try rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgblibffi_fn_method_wallet_issue_asset_nia(self.uniffiClonePointer(),
        FfiConverterTypeOnline.lower(online),
        FfiConverterString.lower(ticker),
        FfiConverterString.lower(name),
        FfiConverterUInt8.lower(precision),
        FfiConverterSequenceUInt64.lower(amounts),$0
    )
})
}
    
open func issueAssetUda(online: Online, ticker: String, name: String, details: String?, precision: UInt8, mediaFilePath: String?, attachmentsFilePaths: [String])throws  -> AssetUda {
    return try  FfiConverterTypeAssetUDA.lift(try rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgblibffi_fn_method_wallet_issue_asset_uda(self.uniffiClonePointer(),
        FfiConverterTypeOnline.lower(online),
        FfiConverterString.lower(ticker),
        FfiConverterString.lower(name),
        FfiConverterOptionString.lower(details),
        FfiConverterUInt8.lower(precision),
        FfiConverterOptionString.lower(mediaFilePath),
        FfiConverterSequenceString.lower(attachmentsFilePaths),$0
    )
})
}
    
open func listAssets(filterAssetSchemas: [AssetSchema])throws  -> Assets {
    return try  FfiConverterTypeAssets.lift(try rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgblibffi_fn_method_wallet_list_assets(self.uniffiClonePointer(),
        FfiConverterSequenceTypeAssetSchema.lower(filterAssetSchemas),$0
    )
})
}
    
open func listTransactions(online: Online?)throws  -> [Transaction] {
    return try  FfiConverterSequenceTypeTransaction.lift(try rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgblibffi_fn_method_wallet_list_transactions(self.uniffiClonePointer(),
        FfiConverterOptionTypeOnline.lower(online),$0
    )
})
}
    
open func listTransfers(assetId: String?)throws  -> [Transfer] {
    return try  FfiConverterSequenceTypeTransfer.lift(try rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgblibffi_fn_method_wallet_list_transfers(self.uniffiClonePointer(),
        FfiConverterOptionString.lower(assetId),$0
    )
})
}
    
open func listUnspents(online: Online?, settledOnly: Bool)throws  -> [Unspent] {
    return try  FfiConverterSequenceTypeUnspent.lift(try rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgblibffi_fn_method_wallet_list_unspents(self.uniffiClonePointer(),
        FfiConverterOptionTypeOnline.lower(online),
        FfiConverterBool.lower(settledOnly),$0
    )
})
}
    
open func refresh(online: Online, assetId: String?, filter: [RefreshFilter])throws  -> [Int32: RefreshedTransfer] {
    return try  FfiConverterDictionaryInt32TypeRefreshedTransfer.lift(try rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgblibffi_fn_method_wallet_refresh(self.uniffiClonePointer(),
        FfiConverterTypeOnline.lower(online),
        FfiConverterOptionString.lower(assetId),
        FfiConverterSequenceTypeRefreshFilter.lower(filter),$0
    )
})
}
    
open func send(online: Online, recipientMap: [String: [Recipient]], donation: Bool, feeRate: Float, minConfirmations: UInt8)throws  -> SendResult {
    return try  FfiConverterTypeSendResult.lift(try rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgblibffi_fn_method_wallet_send(self.uniffiClonePointer(),
        FfiConverterTypeOnline.lower(online),
        FfiConverterDictionaryStringSequenceTypeRecipient.lower(recipientMap),
        FfiConverterBool.lower(donation),
        FfiConverterFloat.lower(feeRate),
        FfiConverterUInt8.lower(minConfirmations),$0
    )
})
}
    
open func sendBegin(online: Online, recipientMap: [String: [Recipient]], donation: Bool, feeRate: Float, minConfirmations: UInt8)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgblibffi_fn_method_wallet_send_begin(self.uniffiClonePointer(),
        FfiConverterTypeOnline.lower(online),
        FfiConverterDictionaryStringSequenceTypeRecipient.lower(recipientMap),
        FfiConverterBool.lower(donation),
        FfiConverterFloat.lower(feeRate),
        FfiConverterUInt8.lower(minConfirmations),$0
    )
})
}
    
open func sendBtc(online: Online, address: String, amount: UInt64, feeRate: Float)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgblibffi_fn_method_wallet_send_btc(self.uniffiClonePointer(),
        FfiConverterTypeOnline.lower(online),
        FfiConverterString.lower(address),
        FfiConverterUInt64.lower(amount),
        FfiConverterFloat.lower(feeRate),$0
    )
})
}
    
open func sendBtcBegin(online: Online, address: String, amount: UInt64, feeRate: Float)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgblibffi_fn_method_wallet_send_btc_begin(self.uniffiClonePointer(),
        FfiConverterTypeOnline.lower(online),
        FfiConverterString.lower(address),
        FfiConverterUInt64.lower(amount),
        FfiConverterFloat.lower(feeRate),$0
    )
})
}
    
open func sendBtcEnd(online: Online, signedPsbt: String)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgblibffi_fn_method_wallet_send_btc_end(self.uniffiClonePointer(),
        FfiConverterTypeOnline.lower(online),
        FfiConverterString.lower(signedPsbt),$0
    )
})
}
    
open func sendEnd(online: Online, signedPsbt: String)throws  -> SendResult {
    return try  FfiConverterTypeSendResult.lift(try rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgblibffi_fn_method_wallet_send_end(self.uniffiClonePointer(),
        FfiConverterTypeOnline.lower(online),
        FfiConverterString.lower(signedPsbt),$0
    )
})
}
    
open func signPsbt(unsignedPsbt: String)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgblibffi_fn_method_wallet_sign_psbt(self.uniffiClonePointer(),
        FfiConverterString.lower(unsignedPsbt),$0
    )
})
}
    
open func witnessReceive(assetId: String?, amount: UInt64?, durationSeconds: UInt32?, transportEndpoints: [String], minConfirmations: UInt8)throws  -> ReceiveData {
    return try  FfiConverterTypeReceiveData.lift(try rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgblibffi_fn_method_wallet_witness_receive(self.uniffiClonePointer(),
        FfiConverterOptionString.lower(assetId),
        FfiConverterOptionUInt64.lower(amount),
        FfiConverterOptionUInt32.lower(durationSeconds),
        FfiConverterSequenceString.lower(transportEndpoints),
        FfiConverterUInt8.lower(minConfirmations),$0
    )
})
}
    

}

public struct FfiConverterTypeWallet: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Wallet

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Wallet {
        return Wallet(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Wallet) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Wallet {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Wallet, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeWallet_lift(_ pointer: UnsafeMutableRawPointer) throws -> Wallet {
    return try FfiConverterTypeWallet.lift(pointer)
}

public func FfiConverterTypeWallet_lower(_ value: Wallet) -> UnsafeMutableRawPointer {
    return FfiConverterTypeWallet.lower(value)
}


public struct AssetCfa {
    public var assetId: String
    public var assetIface: AssetIface
    public var name: String
    public var details: String?
    public var precision: UInt8
    public var issuedSupply: UInt64
    public var timestamp: Int64
    public var addedAt: Int64
    public var balance: Balance
    public var media: Media?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(assetId: String, assetIface: AssetIface, name: String, details: String?, precision: UInt8, issuedSupply: UInt64, timestamp: Int64, addedAt: Int64, balance: Balance, media: Media?) {
        self.assetId = assetId
        self.assetIface = assetIface
        self.name = name
        self.details = details
        self.precision = precision
        self.issuedSupply = issuedSupply
        self.timestamp = timestamp
        self.addedAt = addedAt
        self.balance = balance
        self.media = media
    }
}



extension AssetCfa: Equatable, Hashable {
    public static func ==(lhs: AssetCfa, rhs: AssetCfa) -> Bool {
        if lhs.assetId != rhs.assetId {
            return false
        }
        if lhs.assetIface != rhs.assetIface {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.details != rhs.details {
            return false
        }
        if lhs.precision != rhs.precision {
            return false
        }
        if lhs.issuedSupply != rhs.issuedSupply {
            return false
        }
        if lhs.timestamp != rhs.timestamp {
            return false
        }
        if lhs.addedAt != rhs.addedAt {
            return false
        }
        if lhs.balance != rhs.balance {
            return false
        }
        if lhs.media != rhs.media {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(assetId)
        hasher.combine(assetIface)
        hasher.combine(name)
        hasher.combine(details)
        hasher.combine(precision)
        hasher.combine(issuedSupply)
        hasher.combine(timestamp)
        hasher.combine(addedAt)
        hasher.combine(balance)
        hasher.combine(media)
    }
}


public struct FfiConverterTypeAssetCFA: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AssetCfa {
        return
            try AssetCfa(
                assetId: FfiConverterString.read(from: &buf), 
                assetIface: FfiConverterTypeAssetIface.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                details: FfiConverterOptionString.read(from: &buf), 
                precision: FfiConverterUInt8.read(from: &buf), 
                issuedSupply: FfiConverterUInt64.read(from: &buf), 
                timestamp: FfiConverterInt64.read(from: &buf), 
                addedAt: FfiConverterInt64.read(from: &buf), 
                balance: FfiConverterTypeBalance.read(from: &buf), 
                media: FfiConverterOptionTypeMedia.read(from: &buf)
        )
    }

    public static func write(_ value: AssetCfa, into buf: inout [UInt8]) {
        FfiConverterString.write(value.assetId, into: &buf)
        FfiConverterTypeAssetIface.write(value.assetIface, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.details, into: &buf)
        FfiConverterUInt8.write(value.precision, into: &buf)
        FfiConverterUInt64.write(value.issuedSupply, into: &buf)
        FfiConverterInt64.write(value.timestamp, into: &buf)
        FfiConverterInt64.write(value.addedAt, into: &buf)
        FfiConverterTypeBalance.write(value.balance, into: &buf)
        FfiConverterOptionTypeMedia.write(value.media, into: &buf)
    }
}


public func FfiConverterTypeAssetCFA_lift(_ buf: RustBuffer) throws -> AssetCfa {
    return try FfiConverterTypeAssetCFA.lift(buf)
}

public func FfiConverterTypeAssetCFA_lower(_ value: AssetCfa) -> RustBuffer {
    return FfiConverterTypeAssetCFA.lower(value)
}


public struct AssetNia {
    public var assetId: String
    public var assetIface: AssetIface
    public var ticker: String
    public var name: String
    public var details: String?
    public var precision: UInt8
    public var issuedSupply: UInt64
    public var timestamp: Int64
    public var addedAt: Int64
    public var balance: Balance
    public var media: Media?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(assetId: String, assetIface: AssetIface, ticker: String, name: String, details: String?, precision: UInt8, issuedSupply: UInt64, timestamp: Int64, addedAt: Int64, balance: Balance, media: Media?) {
        self.assetId = assetId
        self.assetIface = assetIface
        self.ticker = ticker
        self.name = name
        self.details = details
        self.precision = precision
        self.issuedSupply = issuedSupply
        self.timestamp = timestamp
        self.addedAt = addedAt
        self.balance = balance
        self.media = media
    }
}



extension AssetNia: Equatable, Hashable {
    public static func ==(lhs: AssetNia, rhs: AssetNia) -> Bool {
        if lhs.assetId != rhs.assetId {
            return false
        }
        if lhs.assetIface != rhs.assetIface {
            return false
        }
        if lhs.ticker != rhs.ticker {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.details != rhs.details {
            return false
        }
        if lhs.precision != rhs.precision {
            return false
        }
        if lhs.issuedSupply != rhs.issuedSupply {
            return false
        }
        if lhs.timestamp != rhs.timestamp {
            return false
        }
        if lhs.addedAt != rhs.addedAt {
            return false
        }
        if lhs.balance != rhs.balance {
            return false
        }
        if lhs.media != rhs.media {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(assetId)
        hasher.combine(assetIface)
        hasher.combine(ticker)
        hasher.combine(name)
        hasher.combine(details)
        hasher.combine(precision)
        hasher.combine(issuedSupply)
        hasher.combine(timestamp)
        hasher.combine(addedAt)
        hasher.combine(balance)
        hasher.combine(media)
    }
}


public struct FfiConverterTypeAssetNIA: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AssetNia {
        return
            try AssetNia(
                assetId: FfiConverterString.read(from: &buf), 
                assetIface: FfiConverterTypeAssetIface.read(from: &buf), 
                ticker: FfiConverterString.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                details: FfiConverterOptionString.read(from: &buf), 
                precision: FfiConverterUInt8.read(from: &buf), 
                issuedSupply: FfiConverterUInt64.read(from: &buf), 
                timestamp: FfiConverterInt64.read(from: &buf), 
                addedAt: FfiConverterInt64.read(from: &buf), 
                balance: FfiConverterTypeBalance.read(from: &buf), 
                media: FfiConverterOptionTypeMedia.read(from: &buf)
        )
    }

    public static func write(_ value: AssetNia, into buf: inout [UInt8]) {
        FfiConverterString.write(value.assetId, into: &buf)
        FfiConverterTypeAssetIface.write(value.assetIface, into: &buf)
        FfiConverterString.write(value.ticker, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.details, into: &buf)
        FfiConverterUInt8.write(value.precision, into: &buf)
        FfiConverterUInt64.write(value.issuedSupply, into: &buf)
        FfiConverterInt64.write(value.timestamp, into: &buf)
        FfiConverterInt64.write(value.addedAt, into: &buf)
        FfiConverterTypeBalance.write(value.balance, into: &buf)
        FfiConverterOptionTypeMedia.write(value.media, into: &buf)
    }
}


public func FfiConverterTypeAssetNIA_lift(_ buf: RustBuffer) throws -> AssetNia {
    return try FfiConverterTypeAssetNIA.lift(buf)
}

public func FfiConverterTypeAssetNIA_lower(_ value: AssetNia) -> RustBuffer {
    return FfiConverterTypeAssetNIA.lower(value)
}


public struct AssetUda {
    public var assetId: String
    public var assetIface: AssetIface
    public var ticker: String
    public var name: String
    public var details: String?
    public var precision: UInt8
    public var issuedSupply: UInt64
    public var timestamp: Int64
    public var addedAt: Int64
    public var balance: Balance
    public var token: TokenLight?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(assetId: String, assetIface: AssetIface, ticker: String, name: String, details: String?, precision: UInt8, issuedSupply: UInt64, timestamp: Int64, addedAt: Int64, balance: Balance, token: TokenLight?) {
        self.assetId = assetId
        self.assetIface = assetIface
        self.ticker = ticker
        self.name = name
        self.details = details
        self.precision = precision
        self.issuedSupply = issuedSupply
        self.timestamp = timestamp
        self.addedAt = addedAt
        self.balance = balance
        self.token = token
    }
}



extension AssetUda: Equatable, Hashable {
    public static func ==(lhs: AssetUda, rhs: AssetUda) -> Bool {
        if lhs.assetId != rhs.assetId {
            return false
        }
        if lhs.assetIface != rhs.assetIface {
            return false
        }
        if lhs.ticker != rhs.ticker {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.details != rhs.details {
            return false
        }
        if lhs.precision != rhs.precision {
            return false
        }
        if lhs.issuedSupply != rhs.issuedSupply {
            return false
        }
        if lhs.timestamp != rhs.timestamp {
            return false
        }
        if lhs.addedAt != rhs.addedAt {
            return false
        }
        if lhs.balance != rhs.balance {
            return false
        }
        if lhs.token != rhs.token {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(assetId)
        hasher.combine(assetIface)
        hasher.combine(ticker)
        hasher.combine(name)
        hasher.combine(details)
        hasher.combine(precision)
        hasher.combine(issuedSupply)
        hasher.combine(timestamp)
        hasher.combine(addedAt)
        hasher.combine(balance)
        hasher.combine(token)
    }
}


public struct FfiConverterTypeAssetUDA: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AssetUda {
        return
            try AssetUda(
                assetId: FfiConverterString.read(from: &buf), 
                assetIface: FfiConverterTypeAssetIface.read(from: &buf), 
                ticker: FfiConverterString.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                details: FfiConverterOptionString.read(from: &buf), 
                precision: FfiConverterUInt8.read(from: &buf), 
                issuedSupply: FfiConverterUInt64.read(from: &buf), 
                timestamp: FfiConverterInt64.read(from: &buf), 
                addedAt: FfiConverterInt64.read(from: &buf), 
                balance: FfiConverterTypeBalance.read(from: &buf), 
                token: FfiConverterOptionTypeTokenLight.read(from: &buf)
        )
    }

    public static func write(_ value: AssetUda, into buf: inout [UInt8]) {
        FfiConverterString.write(value.assetId, into: &buf)
        FfiConverterTypeAssetIface.write(value.assetIface, into: &buf)
        FfiConverterString.write(value.ticker, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.details, into: &buf)
        FfiConverterUInt8.write(value.precision, into: &buf)
        FfiConverterUInt64.write(value.issuedSupply, into: &buf)
        FfiConverterInt64.write(value.timestamp, into: &buf)
        FfiConverterInt64.write(value.addedAt, into: &buf)
        FfiConverterTypeBalance.write(value.balance, into: &buf)
        FfiConverterOptionTypeTokenLight.write(value.token, into: &buf)
    }
}


public func FfiConverterTypeAssetUDA_lift(_ buf: RustBuffer) throws -> AssetUda {
    return try FfiConverterTypeAssetUDA.lift(buf)
}

public func FfiConverterTypeAssetUDA_lower(_ value: AssetUda) -> RustBuffer {
    return FfiConverterTypeAssetUDA.lower(value)
}


public struct Assets {
    public var nia: [AssetNia]?
    public var uda: [AssetUda]?
    public var cfa: [AssetCfa]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(nia: [AssetNia]?, uda: [AssetUda]?, cfa: [AssetCfa]?) {
        self.nia = nia
        self.uda = uda
        self.cfa = cfa
    }
}



extension Assets: Equatable, Hashable {
    public static func ==(lhs: Assets, rhs: Assets) -> Bool {
        if lhs.nia != rhs.nia {
            return false
        }
        if lhs.uda != rhs.uda {
            return false
        }
        if lhs.cfa != rhs.cfa {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(nia)
        hasher.combine(uda)
        hasher.combine(cfa)
    }
}


public struct FfiConverterTypeAssets: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Assets {
        return
            try Assets(
                nia: FfiConverterOptionSequenceTypeAssetNIA.read(from: &buf), 
                uda: FfiConverterOptionSequenceTypeAssetUDA.read(from: &buf), 
                cfa: FfiConverterOptionSequenceTypeAssetCFA.read(from: &buf)
        )
    }

    public static func write(_ value: Assets, into buf: inout [UInt8]) {
        FfiConverterOptionSequenceTypeAssetNIA.write(value.nia, into: &buf)
        FfiConverterOptionSequenceTypeAssetUDA.write(value.uda, into: &buf)
        FfiConverterOptionSequenceTypeAssetCFA.write(value.cfa, into: &buf)
    }
}


public func FfiConverterTypeAssets_lift(_ buf: RustBuffer) throws -> Assets {
    return try FfiConverterTypeAssets.lift(buf)
}

public func FfiConverterTypeAssets_lower(_ value: Assets) -> RustBuffer {
    return FfiConverterTypeAssets.lower(value)
}


public struct Balance {
    public var settled: UInt64
    public var future: UInt64
    public var spendable: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(settled: UInt64, future: UInt64, spendable: UInt64) {
        self.settled = settled
        self.future = future
        self.spendable = spendable
    }
}



extension Balance: Equatable, Hashable {
    public static func ==(lhs: Balance, rhs: Balance) -> Bool {
        if lhs.settled != rhs.settled {
            return false
        }
        if lhs.future != rhs.future {
            return false
        }
        if lhs.spendable != rhs.spendable {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(settled)
        hasher.combine(future)
        hasher.combine(spendable)
    }
}


public struct FfiConverterTypeBalance: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Balance {
        return
            try Balance(
                settled: FfiConverterUInt64.read(from: &buf), 
                future: FfiConverterUInt64.read(from: &buf), 
                spendable: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: Balance, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.settled, into: &buf)
        FfiConverterUInt64.write(value.future, into: &buf)
        FfiConverterUInt64.write(value.spendable, into: &buf)
    }
}


public func FfiConverterTypeBalance_lift(_ buf: RustBuffer) throws -> Balance {
    return try FfiConverterTypeBalance.lift(buf)
}

public func FfiConverterTypeBalance_lower(_ value: Balance) -> RustBuffer {
    return FfiConverterTypeBalance.lower(value)
}


public struct BlockTime {
    public var height: UInt32
    public var timestamp: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(height: UInt32, timestamp: UInt64) {
        self.height = height
        self.timestamp = timestamp
    }
}



extension BlockTime: Equatable, Hashable {
    public static func ==(lhs: BlockTime, rhs: BlockTime) -> Bool {
        if lhs.height != rhs.height {
            return false
        }
        if lhs.timestamp != rhs.timestamp {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(height)
        hasher.combine(timestamp)
    }
}


public struct FfiConverterTypeBlockTime: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BlockTime {
        return
            try BlockTime(
                height: FfiConverterUInt32.read(from: &buf), 
                timestamp: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: BlockTime, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.height, into: &buf)
        FfiConverterUInt64.write(value.timestamp, into: &buf)
    }
}


public func FfiConverterTypeBlockTime_lift(_ buf: RustBuffer) throws -> BlockTime {
    return try FfiConverterTypeBlockTime.lift(buf)
}

public func FfiConverterTypeBlockTime_lower(_ value: BlockTime) -> RustBuffer {
    return FfiConverterTypeBlockTime.lower(value)
}


public struct BtcBalance {
    public var vanilla: Balance
    public var colored: Balance

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(vanilla: Balance, colored: Balance) {
        self.vanilla = vanilla
        self.colored = colored
    }
}



extension BtcBalance: Equatable, Hashable {
    public static func ==(lhs: BtcBalance, rhs: BtcBalance) -> Bool {
        if lhs.vanilla != rhs.vanilla {
            return false
        }
        if lhs.colored != rhs.colored {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(vanilla)
        hasher.combine(colored)
    }
}


public struct FfiConverterTypeBtcBalance: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BtcBalance {
        return
            try BtcBalance(
                vanilla: FfiConverterTypeBalance.read(from: &buf), 
                colored: FfiConverterTypeBalance.read(from: &buf)
        )
    }

    public static func write(_ value: BtcBalance, into buf: inout [UInt8]) {
        FfiConverterTypeBalance.write(value.vanilla, into: &buf)
        FfiConverterTypeBalance.write(value.colored, into: &buf)
    }
}


public func FfiConverterTypeBtcBalance_lift(_ buf: RustBuffer) throws -> BtcBalance {
    return try FfiConverterTypeBtcBalance.lift(buf)
}

public func FfiConverterTypeBtcBalance_lower(_ value: BtcBalance) -> RustBuffer {
    return FfiConverterTypeBtcBalance.lower(value)
}


public struct EmbeddedMedia {
    public var mime: String
    public var data: [UInt8]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(mime: String, data: [UInt8]) {
        self.mime = mime
        self.data = data
    }
}



extension EmbeddedMedia: Equatable, Hashable {
    public static func ==(lhs: EmbeddedMedia, rhs: EmbeddedMedia) -> Bool {
        if lhs.mime != rhs.mime {
            return false
        }
        if lhs.data != rhs.data {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(mime)
        hasher.combine(data)
    }
}


public struct FfiConverterTypeEmbeddedMedia: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EmbeddedMedia {
        return
            try EmbeddedMedia(
                mime: FfiConverterString.read(from: &buf), 
                data: FfiConverterSequenceUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: EmbeddedMedia, into buf: inout [UInt8]) {
        FfiConverterString.write(value.mime, into: &buf)
        FfiConverterSequenceUInt8.write(value.data, into: &buf)
    }
}


public func FfiConverterTypeEmbeddedMedia_lift(_ buf: RustBuffer) throws -> EmbeddedMedia {
    return try FfiConverterTypeEmbeddedMedia.lift(buf)
}

public func FfiConverterTypeEmbeddedMedia_lower(_ value: EmbeddedMedia) -> RustBuffer {
    return FfiConverterTypeEmbeddedMedia.lower(value)
}


public struct InvoiceData {
    public var recipientId: String
    public var assetIface: AssetIface?
    public var assetId: String?
    public var amount: UInt64?
    public var network: BitcoinNetwork
    public var expirationTimestamp: Int64?
    public var transportEndpoints: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(recipientId: String, assetIface: AssetIface?, assetId: String?, amount: UInt64?, network: BitcoinNetwork, expirationTimestamp: Int64?, transportEndpoints: [String]) {
        self.recipientId = recipientId
        self.assetIface = assetIface
        self.assetId = assetId
        self.amount = amount
        self.network = network
        self.expirationTimestamp = expirationTimestamp
        self.transportEndpoints = transportEndpoints
    }
}



extension InvoiceData: Equatable, Hashable {
    public static func ==(lhs: InvoiceData, rhs: InvoiceData) -> Bool {
        if lhs.recipientId != rhs.recipientId {
            return false
        }
        if lhs.assetIface != rhs.assetIface {
            return false
        }
        if lhs.assetId != rhs.assetId {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.network != rhs.network {
            return false
        }
        if lhs.expirationTimestamp != rhs.expirationTimestamp {
            return false
        }
        if lhs.transportEndpoints != rhs.transportEndpoints {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(recipientId)
        hasher.combine(assetIface)
        hasher.combine(assetId)
        hasher.combine(amount)
        hasher.combine(network)
        hasher.combine(expirationTimestamp)
        hasher.combine(transportEndpoints)
    }
}


public struct FfiConverterTypeInvoiceData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InvoiceData {
        return
            try InvoiceData(
                recipientId: FfiConverterString.read(from: &buf), 
                assetIface: FfiConverterOptionTypeAssetIface.read(from: &buf), 
                assetId: FfiConverterOptionString.read(from: &buf), 
                amount: FfiConverterOptionUInt64.read(from: &buf), 
                network: FfiConverterTypeBitcoinNetwork.read(from: &buf), 
                expirationTimestamp: FfiConverterOptionInt64.read(from: &buf), 
                transportEndpoints: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: InvoiceData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.recipientId, into: &buf)
        FfiConverterOptionTypeAssetIface.write(value.assetIface, into: &buf)
        FfiConverterOptionString.write(value.assetId, into: &buf)
        FfiConverterOptionUInt64.write(value.amount, into: &buf)
        FfiConverterTypeBitcoinNetwork.write(value.network, into: &buf)
        FfiConverterOptionInt64.write(value.expirationTimestamp, into: &buf)
        FfiConverterSequenceString.write(value.transportEndpoints, into: &buf)
    }
}


public func FfiConverterTypeInvoiceData_lift(_ buf: RustBuffer) throws -> InvoiceData {
    return try FfiConverterTypeInvoiceData.lift(buf)
}

public func FfiConverterTypeInvoiceData_lower(_ value: InvoiceData) -> RustBuffer {
    return FfiConverterTypeInvoiceData.lower(value)
}


public struct Keys {
    public var mnemonic: String
    public var xpub: String
    public var accountXpub: String
    public var accountXpubFingerprint: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(mnemonic: String, xpub: String, accountXpub: String, accountXpubFingerprint: String) {
        self.mnemonic = mnemonic
        self.xpub = xpub
        self.accountXpub = accountXpub
        self.accountXpubFingerprint = accountXpubFingerprint
    }
}



extension Keys: Equatable, Hashable {
    public static func ==(lhs: Keys, rhs: Keys) -> Bool {
        if lhs.mnemonic != rhs.mnemonic {
            return false
        }
        if lhs.xpub != rhs.xpub {
            return false
        }
        if lhs.accountXpub != rhs.accountXpub {
            return false
        }
        if lhs.accountXpubFingerprint != rhs.accountXpubFingerprint {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(mnemonic)
        hasher.combine(xpub)
        hasher.combine(accountXpub)
        hasher.combine(accountXpubFingerprint)
    }
}


public struct FfiConverterTypeKeys: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Keys {
        return
            try Keys(
                mnemonic: FfiConverterString.read(from: &buf), 
                xpub: FfiConverterString.read(from: &buf), 
                accountXpub: FfiConverterString.read(from: &buf), 
                accountXpubFingerprint: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Keys, into buf: inout [UInt8]) {
        FfiConverterString.write(value.mnemonic, into: &buf)
        FfiConverterString.write(value.xpub, into: &buf)
        FfiConverterString.write(value.accountXpub, into: &buf)
        FfiConverterString.write(value.accountXpubFingerprint, into: &buf)
    }
}


public func FfiConverterTypeKeys_lift(_ buf: RustBuffer) throws -> Keys {
    return try FfiConverterTypeKeys.lift(buf)
}

public func FfiConverterTypeKeys_lower(_ value: Keys) -> RustBuffer {
    return FfiConverterTypeKeys.lower(value)
}


public struct Media {
    public var filePath: String
    public var mime: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(filePath: String, mime: String) {
        self.filePath = filePath
        self.mime = mime
    }
}



extension Media: Equatable, Hashable {
    public static func ==(lhs: Media, rhs: Media) -> Bool {
        if lhs.filePath != rhs.filePath {
            return false
        }
        if lhs.mime != rhs.mime {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(filePath)
        hasher.combine(mime)
    }
}


public struct FfiConverterTypeMedia: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Media {
        return
            try Media(
                filePath: FfiConverterString.read(from: &buf), 
                mime: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Media, into buf: inout [UInt8]) {
        FfiConverterString.write(value.filePath, into: &buf)
        FfiConverterString.write(value.mime, into: &buf)
    }
}


public func FfiConverterTypeMedia_lift(_ buf: RustBuffer) throws -> Media {
    return try FfiConverterTypeMedia.lift(buf)
}

public func FfiConverterTypeMedia_lower(_ value: Media) -> RustBuffer {
    return FfiConverterTypeMedia.lower(value)
}


public struct Metadata {
    public var assetIface: AssetIface
    public var assetSchema: AssetSchema
    public var issuedSupply: UInt64
    public var timestamp: Int64
    public var name: String
    public var precision: UInt8
    public var ticker: String?
    public var details: String?
    public var token: Token?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(assetIface: AssetIface, assetSchema: AssetSchema, issuedSupply: UInt64, timestamp: Int64, name: String, precision: UInt8, ticker: String?, details: String?, token: Token?) {
        self.assetIface = assetIface
        self.assetSchema = assetSchema
        self.issuedSupply = issuedSupply
        self.timestamp = timestamp
        self.name = name
        self.precision = precision
        self.ticker = ticker
        self.details = details
        self.token = token
    }
}



extension Metadata: Equatable, Hashable {
    public static func ==(lhs: Metadata, rhs: Metadata) -> Bool {
        if lhs.assetIface != rhs.assetIface {
            return false
        }
        if lhs.assetSchema != rhs.assetSchema {
            return false
        }
        if lhs.issuedSupply != rhs.issuedSupply {
            return false
        }
        if lhs.timestamp != rhs.timestamp {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.precision != rhs.precision {
            return false
        }
        if lhs.ticker != rhs.ticker {
            return false
        }
        if lhs.details != rhs.details {
            return false
        }
        if lhs.token != rhs.token {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(assetIface)
        hasher.combine(assetSchema)
        hasher.combine(issuedSupply)
        hasher.combine(timestamp)
        hasher.combine(name)
        hasher.combine(precision)
        hasher.combine(ticker)
        hasher.combine(details)
        hasher.combine(token)
    }
}


public struct FfiConverterTypeMetadata: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Metadata {
        return
            try Metadata(
                assetIface: FfiConverterTypeAssetIface.read(from: &buf), 
                assetSchema: FfiConverterTypeAssetSchema.read(from: &buf), 
                issuedSupply: FfiConverterUInt64.read(from: &buf), 
                timestamp: FfiConverterInt64.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                precision: FfiConverterUInt8.read(from: &buf), 
                ticker: FfiConverterOptionString.read(from: &buf), 
                details: FfiConverterOptionString.read(from: &buf), 
                token: FfiConverterOptionTypeToken.read(from: &buf)
        )
    }

    public static func write(_ value: Metadata, into buf: inout [UInt8]) {
        FfiConverterTypeAssetIface.write(value.assetIface, into: &buf)
        FfiConverterTypeAssetSchema.write(value.assetSchema, into: &buf)
        FfiConverterUInt64.write(value.issuedSupply, into: &buf)
        FfiConverterInt64.write(value.timestamp, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterUInt8.write(value.precision, into: &buf)
        FfiConverterOptionString.write(value.ticker, into: &buf)
        FfiConverterOptionString.write(value.details, into: &buf)
        FfiConverterOptionTypeToken.write(value.token, into: &buf)
    }
}


public func FfiConverterTypeMetadata_lift(_ buf: RustBuffer) throws -> Metadata {
    return try FfiConverterTypeMetadata.lift(buf)
}

public func FfiConverterTypeMetadata_lower(_ value: Metadata) -> RustBuffer {
    return FfiConverterTypeMetadata.lower(value)
}


public struct Online {
    public var id: UInt64
    public var indexerUrl: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: UInt64, indexerUrl: String) {
        self.id = id
        self.indexerUrl = indexerUrl
    }
}



extension Online: Equatable, Hashable {
    public static func ==(lhs: Online, rhs: Online) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.indexerUrl != rhs.indexerUrl {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(indexerUrl)
    }
}


public struct FfiConverterTypeOnline: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Online {
        return
            try Online(
                id: FfiConverterUInt64.read(from: &buf), 
                indexerUrl: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Online, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.id, into: &buf)
        FfiConverterString.write(value.indexerUrl, into: &buf)
    }
}


public func FfiConverterTypeOnline_lift(_ buf: RustBuffer) throws -> Online {
    return try FfiConverterTypeOnline.lift(buf)
}

public func FfiConverterTypeOnline_lower(_ value: Online) -> RustBuffer {
    return FfiConverterTypeOnline.lower(value)
}


public struct Outpoint {
    public var txid: String
    public var vout: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(txid: String, vout: UInt32) {
        self.txid = txid
        self.vout = vout
    }
}



extension Outpoint: Equatable, Hashable {
    public static func ==(lhs: Outpoint, rhs: Outpoint) -> Bool {
        if lhs.txid != rhs.txid {
            return false
        }
        if lhs.vout != rhs.vout {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(txid)
        hasher.combine(vout)
    }
}


public struct FfiConverterTypeOutpoint: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Outpoint {
        return
            try Outpoint(
                txid: FfiConverterString.read(from: &buf), 
                vout: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: Outpoint, into buf: inout [UInt8]) {
        FfiConverterString.write(value.txid, into: &buf)
        FfiConverterUInt32.write(value.vout, into: &buf)
    }
}


public func FfiConverterTypeOutpoint_lift(_ buf: RustBuffer) throws -> Outpoint {
    return try FfiConverterTypeOutpoint.lift(buf)
}

public func FfiConverterTypeOutpoint_lower(_ value: Outpoint) -> RustBuffer {
    return FfiConverterTypeOutpoint.lower(value)
}


public struct ProofOfReserves {
    public var utxo: Outpoint
    public var proof: [UInt8]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(utxo: Outpoint, proof: [UInt8]) {
        self.utxo = utxo
        self.proof = proof
    }
}



extension ProofOfReserves: Equatable, Hashable {
    public static func ==(lhs: ProofOfReserves, rhs: ProofOfReserves) -> Bool {
        if lhs.utxo != rhs.utxo {
            return false
        }
        if lhs.proof != rhs.proof {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(utxo)
        hasher.combine(proof)
    }
}


public struct FfiConverterTypeProofOfReserves: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProofOfReserves {
        return
            try ProofOfReserves(
                utxo: FfiConverterTypeOutpoint.read(from: &buf), 
                proof: FfiConverterSequenceUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: ProofOfReserves, into buf: inout [UInt8]) {
        FfiConverterTypeOutpoint.write(value.utxo, into: &buf)
        FfiConverterSequenceUInt8.write(value.proof, into: &buf)
    }
}


public func FfiConverterTypeProofOfReserves_lift(_ buf: RustBuffer) throws -> ProofOfReserves {
    return try FfiConverterTypeProofOfReserves.lift(buf)
}

public func FfiConverterTypeProofOfReserves_lower(_ value: ProofOfReserves) -> RustBuffer {
    return FfiConverterTypeProofOfReserves.lower(value)
}


public struct ReceiveData {
    public var invoice: String
    public var recipientId: String
    public var expirationTimestamp: Int64?
    public var batchTransferIdx: Int32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(invoice: String, recipientId: String, expirationTimestamp: Int64?, batchTransferIdx: Int32) {
        self.invoice = invoice
        self.recipientId = recipientId
        self.expirationTimestamp = expirationTimestamp
        self.batchTransferIdx = batchTransferIdx
    }
}



extension ReceiveData: Equatable, Hashable {
    public static func ==(lhs: ReceiveData, rhs: ReceiveData) -> Bool {
        if lhs.invoice != rhs.invoice {
            return false
        }
        if lhs.recipientId != rhs.recipientId {
            return false
        }
        if lhs.expirationTimestamp != rhs.expirationTimestamp {
            return false
        }
        if lhs.batchTransferIdx != rhs.batchTransferIdx {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(invoice)
        hasher.combine(recipientId)
        hasher.combine(expirationTimestamp)
        hasher.combine(batchTransferIdx)
    }
}


public struct FfiConverterTypeReceiveData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ReceiveData {
        return
            try ReceiveData(
                invoice: FfiConverterString.read(from: &buf), 
                recipientId: FfiConverterString.read(from: &buf), 
                expirationTimestamp: FfiConverterOptionInt64.read(from: &buf), 
                batchTransferIdx: FfiConverterInt32.read(from: &buf)
        )
    }

    public static func write(_ value: ReceiveData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.invoice, into: &buf)
        FfiConverterString.write(value.recipientId, into: &buf)
        FfiConverterOptionInt64.write(value.expirationTimestamp, into: &buf)
        FfiConverterInt32.write(value.batchTransferIdx, into: &buf)
    }
}


public func FfiConverterTypeReceiveData_lift(_ buf: RustBuffer) throws -> ReceiveData {
    return try FfiConverterTypeReceiveData.lift(buf)
}

public func FfiConverterTypeReceiveData_lower(_ value: ReceiveData) -> RustBuffer {
    return FfiConverterTypeReceiveData.lower(value)
}


public struct Recipient {
    public var recipientId: String
    public var witnessData: WitnessData?
    public var amount: UInt64
    public var transportEndpoints: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(recipientId: String, witnessData: WitnessData?, amount: UInt64, transportEndpoints: [String]) {
        self.recipientId = recipientId
        self.witnessData = witnessData
        self.amount = amount
        self.transportEndpoints = transportEndpoints
    }
}



extension Recipient: Equatable, Hashable {
    public static func ==(lhs: Recipient, rhs: Recipient) -> Bool {
        if lhs.recipientId != rhs.recipientId {
            return false
        }
        if lhs.witnessData != rhs.witnessData {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.transportEndpoints != rhs.transportEndpoints {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(recipientId)
        hasher.combine(witnessData)
        hasher.combine(amount)
        hasher.combine(transportEndpoints)
    }
}


public struct FfiConverterTypeRecipient: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Recipient {
        return
            try Recipient(
                recipientId: FfiConverterString.read(from: &buf), 
                witnessData: FfiConverterOptionTypeWitnessData.read(from: &buf), 
                amount: FfiConverterUInt64.read(from: &buf), 
                transportEndpoints: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: Recipient, into buf: inout [UInt8]) {
        FfiConverterString.write(value.recipientId, into: &buf)
        FfiConverterOptionTypeWitnessData.write(value.witnessData, into: &buf)
        FfiConverterUInt64.write(value.amount, into: &buf)
        FfiConverterSequenceString.write(value.transportEndpoints, into: &buf)
    }
}


public func FfiConverterTypeRecipient_lift(_ buf: RustBuffer) throws -> Recipient {
    return try FfiConverterTypeRecipient.lift(buf)
}

public func FfiConverterTypeRecipient_lower(_ value: Recipient) -> RustBuffer {
    return FfiConverterTypeRecipient.lower(value)
}


public struct RefreshFilter {
    public var status: RefreshTransferStatus
    public var incoming: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(status: RefreshTransferStatus, incoming: Bool) {
        self.status = status
        self.incoming = incoming
    }
}



extension RefreshFilter: Equatable, Hashable {
    public static func ==(lhs: RefreshFilter, rhs: RefreshFilter) -> Bool {
        if lhs.status != rhs.status {
            return false
        }
        if lhs.incoming != rhs.incoming {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(status)
        hasher.combine(incoming)
    }
}


public struct FfiConverterTypeRefreshFilter: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RefreshFilter {
        return
            try RefreshFilter(
                status: FfiConverterTypeRefreshTransferStatus.read(from: &buf), 
                incoming: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: RefreshFilter, into buf: inout [UInt8]) {
        FfiConverterTypeRefreshTransferStatus.write(value.status, into: &buf)
        FfiConverterBool.write(value.incoming, into: &buf)
    }
}


public func FfiConverterTypeRefreshFilter_lift(_ buf: RustBuffer) throws -> RefreshFilter {
    return try FfiConverterTypeRefreshFilter.lift(buf)
}

public func FfiConverterTypeRefreshFilter_lower(_ value: RefreshFilter) -> RustBuffer {
    return FfiConverterTypeRefreshFilter.lower(value)
}


public struct RefreshedTransfer {
    public var updatedStatus: TransferStatus?
    public var failure: RgbLibError?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(updatedStatus: TransferStatus?, failure: RgbLibError?) {
        self.updatedStatus = updatedStatus
        self.failure = failure
    }
}



extension RefreshedTransfer: Equatable, Hashable {
    public static func ==(lhs: RefreshedTransfer, rhs: RefreshedTransfer) -> Bool {
        if lhs.updatedStatus != rhs.updatedStatus {
            return false
        }
        if lhs.failure != rhs.failure {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(updatedStatus)
        hasher.combine(failure)
    }
}


public struct FfiConverterTypeRefreshedTransfer: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RefreshedTransfer {
        return
            try RefreshedTransfer(
                updatedStatus: FfiConverterOptionTypeTransferStatus.read(from: &buf), 
                failure: FfiConverterOptionTypeRgbLibError.read(from: &buf)
        )
    }

    public static func write(_ value: RefreshedTransfer, into buf: inout [UInt8]) {
        FfiConverterOptionTypeTransferStatus.write(value.updatedStatus, into: &buf)
        FfiConverterOptionTypeRgbLibError.write(value.failure, into: &buf)
    }
}


public func FfiConverterTypeRefreshedTransfer_lift(_ buf: RustBuffer) throws -> RefreshedTransfer {
    return try FfiConverterTypeRefreshedTransfer.lift(buf)
}

public func FfiConverterTypeRefreshedTransfer_lower(_ value: RefreshedTransfer) -> RustBuffer {
    return FfiConverterTypeRefreshedTransfer.lower(value)
}


public struct RgbAllocation {
    public var assetId: String?
    public var amount: UInt64
    public var settled: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(assetId: String?, amount: UInt64, settled: Bool) {
        self.assetId = assetId
        self.amount = amount
        self.settled = settled
    }
}



extension RgbAllocation: Equatable, Hashable {
    public static func ==(lhs: RgbAllocation, rhs: RgbAllocation) -> Bool {
        if lhs.assetId != rhs.assetId {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.settled != rhs.settled {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(assetId)
        hasher.combine(amount)
        hasher.combine(settled)
    }
}


public struct FfiConverterTypeRgbAllocation: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RgbAllocation {
        return
            try RgbAllocation(
                assetId: FfiConverterOptionString.read(from: &buf), 
                amount: FfiConverterUInt64.read(from: &buf), 
                settled: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: RgbAllocation, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.assetId, into: &buf)
        FfiConverterUInt64.write(value.amount, into: &buf)
        FfiConverterBool.write(value.settled, into: &buf)
    }
}


public func FfiConverterTypeRgbAllocation_lift(_ buf: RustBuffer) throws -> RgbAllocation {
    return try FfiConverterTypeRgbAllocation.lift(buf)
}

public func FfiConverterTypeRgbAllocation_lower(_ value: RgbAllocation) -> RustBuffer {
    return FfiConverterTypeRgbAllocation.lower(value)
}


public struct SendResult {
    public var txid: String
    public var batchTransferIdx: Int32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(txid: String, batchTransferIdx: Int32) {
        self.txid = txid
        self.batchTransferIdx = batchTransferIdx
    }
}



extension SendResult: Equatable, Hashable {
    public static func ==(lhs: SendResult, rhs: SendResult) -> Bool {
        if lhs.txid != rhs.txid {
            return false
        }
        if lhs.batchTransferIdx != rhs.batchTransferIdx {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(txid)
        hasher.combine(batchTransferIdx)
    }
}


public struct FfiConverterTypeSendResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendResult {
        return
            try SendResult(
                txid: FfiConverterString.read(from: &buf), 
                batchTransferIdx: FfiConverterInt32.read(from: &buf)
        )
    }

    public static func write(_ value: SendResult, into buf: inout [UInt8]) {
        FfiConverterString.write(value.txid, into: &buf)
        FfiConverterInt32.write(value.batchTransferIdx, into: &buf)
    }
}


public func FfiConverterTypeSendResult_lift(_ buf: RustBuffer) throws -> SendResult {
    return try FfiConverterTypeSendResult.lift(buf)
}

public func FfiConverterTypeSendResult_lower(_ value: SendResult) -> RustBuffer {
    return FfiConverterTypeSendResult.lower(value)
}


public struct Token {
    public var index: UInt32
    public var ticker: String?
    public var name: String?
    public var details: String?
    public var embeddedMedia: EmbeddedMedia?
    public var media: Media?
    public var attachments: [UInt8: Media]
    public var reserves: ProofOfReserves?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(index: UInt32, ticker: String?, name: String?, details: String?, embeddedMedia: EmbeddedMedia?, media: Media?, attachments: [UInt8: Media], reserves: ProofOfReserves?) {
        self.index = index
        self.ticker = ticker
        self.name = name
        self.details = details
        self.embeddedMedia = embeddedMedia
        self.media = media
        self.attachments = attachments
        self.reserves = reserves
    }
}



extension Token: Equatable, Hashable {
    public static func ==(lhs: Token, rhs: Token) -> Bool {
        if lhs.index != rhs.index {
            return false
        }
        if lhs.ticker != rhs.ticker {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.details != rhs.details {
            return false
        }
        if lhs.embeddedMedia != rhs.embeddedMedia {
            return false
        }
        if lhs.media != rhs.media {
            return false
        }
        if lhs.attachments != rhs.attachments {
            return false
        }
        if lhs.reserves != rhs.reserves {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(index)
        hasher.combine(ticker)
        hasher.combine(name)
        hasher.combine(details)
        hasher.combine(embeddedMedia)
        hasher.combine(media)
        hasher.combine(attachments)
        hasher.combine(reserves)
    }
}


public struct FfiConverterTypeToken: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Token {
        return
            try Token(
                index: FfiConverterUInt32.read(from: &buf), 
                ticker: FfiConverterOptionString.read(from: &buf), 
                name: FfiConverterOptionString.read(from: &buf), 
                details: FfiConverterOptionString.read(from: &buf), 
                embeddedMedia: FfiConverterOptionTypeEmbeddedMedia.read(from: &buf), 
                media: FfiConverterOptionTypeMedia.read(from: &buf), 
                attachments: FfiConverterDictionaryUInt8TypeMedia.read(from: &buf), 
                reserves: FfiConverterOptionTypeProofOfReserves.read(from: &buf)
        )
    }

    public static func write(_ value: Token, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.index, into: &buf)
        FfiConverterOptionString.write(value.ticker, into: &buf)
        FfiConverterOptionString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.details, into: &buf)
        FfiConverterOptionTypeEmbeddedMedia.write(value.embeddedMedia, into: &buf)
        FfiConverterOptionTypeMedia.write(value.media, into: &buf)
        FfiConverterDictionaryUInt8TypeMedia.write(value.attachments, into: &buf)
        FfiConverterOptionTypeProofOfReserves.write(value.reserves, into: &buf)
    }
}


public func FfiConverterTypeToken_lift(_ buf: RustBuffer) throws -> Token {
    return try FfiConverterTypeToken.lift(buf)
}

public func FfiConverterTypeToken_lower(_ value: Token) -> RustBuffer {
    return FfiConverterTypeToken.lower(value)
}


public struct TokenLight {
    public var index: UInt32
    public var ticker: String?
    public var name: String?
    public var details: String?
    public var embeddedMedia: Bool
    public var media: Media?
    public var attachments: [UInt8: Media]
    public var reserves: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(index: UInt32, ticker: String?, name: String?, details: String?, embeddedMedia: Bool, media: Media?, attachments: [UInt8: Media], reserves: Bool) {
        self.index = index
        self.ticker = ticker
        self.name = name
        self.details = details
        self.embeddedMedia = embeddedMedia
        self.media = media
        self.attachments = attachments
        self.reserves = reserves
    }
}



extension TokenLight: Equatable, Hashable {
    public static func ==(lhs: TokenLight, rhs: TokenLight) -> Bool {
        if lhs.index != rhs.index {
            return false
        }
        if lhs.ticker != rhs.ticker {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.details != rhs.details {
            return false
        }
        if lhs.embeddedMedia != rhs.embeddedMedia {
            return false
        }
        if lhs.media != rhs.media {
            return false
        }
        if lhs.attachments != rhs.attachments {
            return false
        }
        if lhs.reserves != rhs.reserves {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(index)
        hasher.combine(ticker)
        hasher.combine(name)
        hasher.combine(details)
        hasher.combine(embeddedMedia)
        hasher.combine(media)
        hasher.combine(attachments)
        hasher.combine(reserves)
    }
}


public struct FfiConverterTypeTokenLight: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TokenLight {
        return
            try TokenLight(
                index: FfiConverterUInt32.read(from: &buf), 
                ticker: FfiConverterOptionString.read(from: &buf), 
                name: FfiConverterOptionString.read(from: &buf), 
                details: FfiConverterOptionString.read(from: &buf), 
                embeddedMedia: FfiConverterBool.read(from: &buf), 
                media: FfiConverterOptionTypeMedia.read(from: &buf), 
                attachments: FfiConverterDictionaryUInt8TypeMedia.read(from: &buf), 
                reserves: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: TokenLight, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.index, into: &buf)
        FfiConverterOptionString.write(value.ticker, into: &buf)
        FfiConverterOptionString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.details, into: &buf)
        FfiConverterBool.write(value.embeddedMedia, into: &buf)
        FfiConverterOptionTypeMedia.write(value.media, into: &buf)
        FfiConverterDictionaryUInt8TypeMedia.write(value.attachments, into: &buf)
        FfiConverterBool.write(value.reserves, into: &buf)
    }
}


public func FfiConverterTypeTokenLight_lift(_ buf: RustBuffer) throws -> TokenLight {
    return try FfiConverterTypeTokenLight.lift(buf)
}

public func FfiConverterTypeTokenLight_lower(_ value: TokenLight) -> RustBuffer {
    return FfiConverterTypeTokenLight.lower(value)
}


public struct Transaction {
    public var transactionType: TransactionType
    public var txid: String
    public var received: UInt64
    public var sent: UInt64
    public var fee: UInt64?
    public var confirmationTime: BlockTime?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(transactionType: TransactionType, txid: String, received: UInt64, sent: UInt64, fee: UInt64?, confirmationTime: BlockTime?) {
        self.transactionType = transactionType
        self.txid = txid
        self.received = received
        self.sent = sent
        self.fee = fee
        self.confirmationTime = confirmationTime
    }
}



extension Transaction: Equatable, Hashable {
    public static func ==(lhs: Transaction, rhs: Transaction) -> Bool {
        if lhs.transactionType != rhs.transactionType {
            return false
        }
        if lhs.txid != rhs.txid {
            return false
        }
        if lhs.received != rhs.received {
            return false
        }
        if lhs.sent != rhs.sent {
            return false
        }
        if lhs.fee != rhs.fee {
            return false
        }
        if lhs.confirmationTime != rhs.confirmationTime {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(transactionType)
        hasher.combine(txid)
        hasher.combine(received)
        hasher.combine(sent)
        hasher.combine(fee)
        hasher.combine(confirmationTime)
    }
}


public struct FfiConverterTypeTransaction: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Transaction {
        return
            try Transaction(
                transactionType: FfiConverterTypeTransactionType.read(from: &buf), 
                txid: FfiConverterString.read(from: &buf), 
                received: FfiConverterUInt64.read(from: &buf), 
                sent: FfiConverterUInt64.read(from: &buf), 
                fee: FfiConverterOptionUInt64.read(from: &buf), 
                confirmationTime: FfiConverterOptionTypeBlockTime.read(from: &buf)
        )
    }

    public static func write(_ value: Transaction, into buf: inout [UInt8]) {
        FfiConverterTypeTransactionType.write(value.transactionType, into: &buf)
        FfiConverterString.write(value.txid, into: &buf)
        FfiConverterUInt64.write(value.received, into: &buf)
        FfiConverterUInt64.write(value.sent, into: &buf)
        FfiConverterOptionUInt64.write(value.fee, into: &buf)
        FfiConverterOptionTypeBlockTime.write(value.confirmationTime, into: &buf)
    }
}


public func FfiConverterTypeTransaction_lift(_ buf: RustBuffer) throws -> Transaction {
    return try FfiConverterTypeTransaction.lift(buf)
}

public func FfiConverterTypeTransaction_lower(_ value: Transaction) -> RustBuffer {
    return FfiConverterTypeTransaction.lower(value)
}


public struct Transfer {
    public var idx: Int32
    public var batchTransferIdx: Int32
    public var createdAt: Int64
    public var updatedAt: Int64
    public var status: TransferStatus
    public var amount: UInt64
    public var kind: TransferKind
    public var txid: String?
    public var recipientId: String?
    public var receiveUtxo: Outpoint?
    public var changeUtxo: Outpoint?
    public var expiration: Int64?
    public var transportEndpoints: [TransferTransportEndpoint]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(idx: Int32, batchTransferIdx: Int32, createdAt: Int64, updatedAt: Int64, status: TransferStatus, amount: UInt64, kind: TransferKind, txid: String?, recipientId: String?, receiveUtxo: Outpoint?, changeUtxo: Outpoint?, expiration: Int64?, transportEndpoints: [TransferTransportEndpoint]) {
        self.idx = idx
        self.batchTransferIdx = batchTransferIdx
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.status = status
        self.amount = amount
        self.kind = kind
        self.txid = txid
        self.recipientId = recipientId
        self.receiveUtxo = receiveUtxo
        self.changeUtxo = changeUtxo
        self.expiration = expiration
        self.transportEndpoints = transportEndpoints
    }
}



extension Transfer: Equatable, Hashable {
    public static func ==(lhs: Transfer, rhs: Transfer) -> Bool {
        if lhs.idx != rhs.idx {
            return false
        }
        if lhs.batchTransferIdx != rhs.batchTransferIdx {
            return false
        }
        if lhs.createdAt != rhs.createdAt {
            return false
        }
        if lhs.updatedAt != rhs.updatedAt {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.kind != rhs.kind {
            return false
        }
        if lhs.txid != rhs.txid {
            return false
        }
        if lhs.recipientId != rhs.recipientId {
            return false
        }
        if lhs.receiveUtxo != rhs.receiveUtxo {
            return false
        }
        if lhs.changeUtxo != rhs.changeUtxo {
            return false
        }
        if lhs.expiration != rhs.expiration {
            return false
        }
        if lhs.transportEndpoints != rhs.transportEndpoints {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(idx)
        hasher.combine(batchTransferIdx)
        hasher.combine(createdAt)
        hasher.combine(updatedAt)
        hasher.combine(status)
        hasher.combine(amount)
        hasher.combine(kind)
        hasher.combine(txid)
        hasher.combine(recipientId)
        hasher.combine(receiveUtxo)
        hasher.combine(changeUtxo)
        hasher.combine(expiration)
        hasher.combine(transportEndpoints)
    }
}


public struct FfiConverterTypeTransfer: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Transfer {
        return
            try Transfer(
                idx: FfiConverterInt32.read(from: &buf), 
                batchTransferIdx: FfiConverterInt32.read(from: &buf), 
                createdAt: FfiConverterInt64.read(from: &buf), 
                updatedAt: FfiConverterInt64.read(from: &buf), 
                status: FfiConverterTypeTransferStatus.read(from: &buf), 
                amount: FfiConverterUInt64.read(from: &buf), 
                kind: FfiConverterTypeTransferKind.read(from: &buf), 
                txid: FfiConverterOptionString.read(from: &buf), 
                recipientId: FfiConverterOptionString.read(from: &buf), 
                receiveUtxo: FfiConverterOptionTypeOutpoint.read(from: &buf), 
                changeUtxo: FfiConverterOptionTypeOutpoint.read(from: &buf), 
                expiration: FfiConverterOptionInt64.read(from: &buf), 
                transportEndpoints: FfiConverterSequenceTypeTransferTransportEndpoint.read(from: &buf)
        )
    }

    public static func write(_ value: Transfer, into buf: inout [UInt8]) {
        FfiConverterInt32.write(value.idx, into: &buf)
        FfiConverterInt32.write(value.batchTransferIdx, into: &buf)
        FfiConverterInt64.write(value.createdAt, into: &buf)
        FfiConverterInt64.write(value.updatedAt, into: &buf)
        FfiConverterTypeTransferStatus.write(value.status, into: &buf)
        FfiConverterUInt64.write(value.amount, into: &buf)
        FfiConverterTypeTransferKind.write(value.kind, into: &buf)
        FfiConverterOptionString.write(value.txid, into: &buf)
        FfiConverterOptionString.write(value.recipientId, into: &buf)
        FfiConverterOptionTypeOutpoint.write(value.receiveUtxo, into: &buf)
        FfiConverterOptionTypeOutpoint.write(value.changeUtxo, into: &buf)
        FfiConverterOptionInt64.write(value.expiration, into: &buf)
        FfiConverterSequenceTypeTransferTransportEndpoint.write(value.transportEndpoints, into: &buf)
    }
}


public func FfiConverterTypeTransfer_lift(_ buf: RustBuffer) throws -> Transfer {
    return try FfiConverterTypeTransfer.lift(buf)
}

public func FfiConverterTypeTransfer_lower(_ value: Transfer) -> RustBuffer {
    return FfiConverterTypeTransfer.lower(value)
}


public struct TransferTransportEndpoint {
    public var endpoint: String
    public var transportType: TransportType
    public var used: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(endpoint: String, transportType: TransportType, used: Bool) {
        self.endpoint = endpoint
        self.transportType = transportType
        self.used = used
    }
}



extension TransferTransportEndpoint: Equatable, Hashable {
    public static func ==(lhs: TransferTransportEndpoint, rhs: TransferTransportEndpoint) -> Bool {
        if lhs.endpoint != rhs.endpoint {
            return false
        }
        if lhs.transportType != rhs.transportType {
            return false
        }
        if lhs.used != rhs.used {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(endpoint)
        hasher.combine(transportType)
        hasher.combine(used)
    }
}


public struct FfiConverterTypeTransferTransportEndpoint: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransferTransportEndpoint {
        return
            try TransferTransportEndpoint(
                endpoint: FfiConverterString.read(from: &buf), 
                transportType: FfiConverterTypeTransportType.read(from: &buf), 
                used: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: TransferTransportEndpoint, into buf: inout [UInt8]) {
        FfiConverterString.write(value.endpoint, into: &buf)
        FfiConverterTypeTransportType.write(value.transportType, into: &buf)
        FfiConverterBool.write(value.used, into: &buf)
    }
}


public func FfiConverterTypeTransferTransportEndpoint_lift(_ buf: RustBuffer) throws -> TransferTransportEndpoint {
    return try FfiConverterTypeTransferTransportEndpoint.lift(buf)
}

public func FfiConverterTypeTransferTransportEndpoint_lower(_ value: TransferTransportEndpoint) -> RustBuffer {
    return FfiConverterTypeTransferTransportEndpoint.lower(value)
}


public struct Unspent {
    public var utxo: Utxo
    public var rgbAllocations: [RgbAllocation]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(utxo: Utxo, rgbAllocations: [RgbAllocation]) {
        self.utxo = utxo
        self.rgbAllocations = rgbAllocations
    }
}



extension Unspent: Equatable, Hashable {
    public static func ==(lhs: Unspent, rhs: Unspent) -> Bool {
        if lhs.utxo != rhs.utxo {
            return false
        }
        if lhs.rgbAllocations != rhs.rgbAllocations {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(utxo)
        hasher.combine(rgbAllocations)
    }
}


public struct FfiConverterTypeUnspent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Unspent {
        return
            try Unspent(
                utxo: FfiConverterTypeUtxo.read(from: &buf), 
                rgbAllocations: FfiConverterSequenceTypeRgbAllocation.read(from: &buf)
        )
    }

    public static func write(_ value: Unspent, into buf: inout [UInt8]) {
        FfiConverterTypeUtxo.write(value.utxo, into: &buf)
        FfiConverterSequenceTypeRgbAllocation.write(value.rgbAllocations, into: &buf)
    }
}


public func FfiConverterTypeUnspent_lift(_ buf: RustBuffer) throws -> Unspent {
    return try FfiConverterTypeUnspent.lift(buf)
}

public func FfiConverterTypeUnspent_lower(_ value: Unspent) -> RustBuffer {
    return FfiConverterTypeUnspent.lower(value)
}


public struct Utxo {
    public var outpoint: Outpoint
    public var btcAmount: UInt64
    public var colorable: Bool
    public var exists: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(outpoint: Outpoint, btcAmount: UInt64, colorable: Bool, exists: Bool) {
        self.outpoint = outpoint
        self.btcAmount = btcAmount
        self.colorable = colorable
        self.exists = exists
    }
}



extension Utxo: Equatable, Hashable {
    public static func ==(lhs: Utxo, rhs: Utxo) -> Bool {
        if lhs.outpoint != rhs.outpoint {
            return false
        }
        if lhs.btcAmount != rhs.btcAmount {
            return false
        }
        if lhs.colorable != rhs.colorable {
            return false
        }
        if lhs.exists != rhs.exists {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(outpoint)
        hasher.combine(btcAmount)
        hasher.combine(colorable)
        hasher.combine(exists)
    }
}


public struct FfiConverterTypeUtxo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Utxo {
        return
            try Utxo(
                outpoint: FfiConverterTypeOutpoint.read(from: &buf), 
                btcAmount: FfiConverterUInt64.read(from: &buf), 
                colorable: FfiConverterBool.read(from: &buf), 
                exists: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: Utxo, into buf: inout [UInt8]) {
        FfiConverterTypeOutpoint.write(value.outpoint, into: &buf)
        FfiConverterUInt64.write(value.btcAmount, into: &buf)
        FfiConverterBool.write(value.colorable, into: &buf)
        FfiConverterBool.write(value.exists, into: &buf)
    }
}


public func FfiConverterTypeUtxo_lift(_ buf: RustBuffer) throws -> Utxo {
    return try FfiConverterTypeUtxo.lift(buf)
}

public func FfiConverterTypeUtxo_lower(_ value: Utxo) -> RustBuffer {
    return FfiConverterTypeUtxo.lower(value)
}


public struct WalletData {
    public var dataDir: String
    public var bitcoinNetwork: BitcoinNetwork
    public var databaseType: DatabaseType
    public var maxAllocationsPerUtxo: UInt32
    public var pubkey: String
    public var mnemonic: String?
    public var vanillaKeychain: UInt8?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(dataDir: String, bitcoinNetwork: BitcoinNetwork, databaseType: DatabaseType, maxAllocationsPerUtxo: UInt32, pubkey: String, mnemonic: String?, vanillaKeychain: UInt8?) {
        self.dataDir = dataDir
        self.bitcoinNetwork = bitcoinNetwork
        self.databaseType = databaseType
        self.maxAllocationsPerUtxo = maxAllocationsPerUtxo
        self.pubkey = pubkey
        self.mnemonic = mnemonic
        self.vanillaKeychain = vanillaKeychain
    }
}



extension WalletData: Equatable, Hashable {
    public static func ==(lhs: WalletData, rhs: WalletData) -> Bool {
        if lhs.dataDir != rhs.dataDir {
            return false
        }
        if lhs.bitcoinNetwork != rhs.bitcoinNetwork {
            return false
        }
        if lhs.databaseType != rhs.databaseType {
            return false
        }
        if lhs.maxAllocationsPerUtxo != rhs.maxAllocationsPerUtxo {
            return false
        }
        if lhs.pubkey != rhs.pubkey {
            return false
        }
        if lhs.mnemonic != rhs.mnemonic {
            return false
        }
        if lhs.vanillaKeychain != rhs.vanillaKeychain {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(dataDir)
        hasher.combine(bitcoinNetwork)
        hasher.combine(databaseType)
        hasher.combine(maxAllocationsPerUtxo)
        hasher.combine(pubkey)
        hasher.combine(mnemonic)
        hasher.combine(vanillaKeychain)
    }
}


public struct FfiConverterTypeWalletData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletData {
        return
            try WalletData(
                dataDir: FfiConverterString.read(from: &buf), 
                bitcoinNetwork: FfiConverterTypeBitcoinNetwork.read(from: &buf), 
                databaseType: FfiConverterTypeDatabaseType.read(from: &buf), 
                maxAllocationsPerUtxo: FfiConverterUInt32.read(from: &buf), 
                pubkey: FfiConverterString.read(from: &buf), 
                mnemonic: FfiConverterOptionString.read(from: &buf), 
                vanillaKeychain: FfiConverterOptionUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: WalletData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.dataDir, into: &buf)
        FfiConverterTypeBitcoinNetwork.write(value.bitcoinNetwork, into: &buf)
        FfiConverterTypeDatabaseType.write(value.databaseType, into: &buf)
        FfiConverterUInt32.write(value.maxAllocationsPerUtxo, into: &buf)
        FfiConverterString.write(value.pubkey, into: &buf)
        FfiConverterOptionString.write(value.mnemonic, into: &buf)
        FfiConverterOptionUInt8.write(value.vanillaKeychain, into: &buf)
    }
}


public func FfiConverterTypeWalletData_lift(_ buf: RustBuffer) throws -> WalletData {
    return try FfiConverterTypeWalletData.lift(buf)
}

public func FfiConverterTypeWalletData_lower(_ value: WalletData) -> RustBuffer {
    return FfiConverterTypeWalletData.lower(value)
}


public struct WitnessData {
    public var amountSat: UInt64
    public var blinding: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(amountSat: UInt64, blinding: UInt64?) {
        self.amountSat = amountSat
        self.blinding = blinding
    }
}



extension WitnessData: Equatable, Hashable {
    public static func ==(lhs: WitnessData, rhs: WitnessData) -> Bool {
        if lhs.amountSat != rhs.amountSat {
            return false
        }
        if lhs.blinding != rhs.blinding {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(amountSat)
        hasher.combine(blinding)
    }
}


public struct FfiConverterTypeWitnessData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WitnessData {
        return
            try WitnessData(
                amountSat: FfiConverterUInt64.read(from: &buf), 
                blinding: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: WitnessData, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.amountSat, into: &buf)
        FfiConverterOptionUInt64.write(value.blinding, into: &buf)
    }
}


public func FfiConverterTypeWitnessData_lift(_ buf: RustBuffer) throws -> WitnessData {
    return try FfiConverterTypeWitnessData.lift(buf)
}

public func FfiConverterTypeWitnessData_lower(_ value: WitnessData) -> RustBuffer {
    return FfiConverterTypeWitnessData.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum AssetIface {
    
    case rgb20
    case rgb21
    case rgb25
}


public struct FfiConverterTypeAssetIface: FfiConverterRustBuffer {
    typealias SwiftType = AssetIface

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AssetIface {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .rgb20
        
        case 2: return .rgb21
        
        case 3: return .rgb25
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AssetIface, into buf: inout [UInt8]) {
        switch value {
        
        
        case .rgb20:
            writeInt(&buf, Int32(1))
        
        
        case .rgb21:
            writeInt(&buf, Int32(2))
        
        
        case .rgb25:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeAssetIface_lift(_ buf: RustBuffer) throws -> AssetIface {
    return try FfiConverterTypeAssetIface.lift(buf)
}

public func FfiConverterTypeAssetIface_lower(_ value: AssetIface) -> RustBuffer {
    return FfiConverterTypeAssetIface.lower(value)
}



extension AssetIface: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum AssetSchema {
    
    case nia
    case uda
    case cfa
}


public struct FfiConverterTypeAssetSchema: FfiConverterRustBuffer {
    typealias SwiftType = AssetSchema

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AssetSchema {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .nia
        
        case 2: return .uda
        
        case 3: return .cfa
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AssetSchema, into buf: inout [UInt8]) {
        switch value {
        
        
        case .nia:
            writeInt(&buf, Int32(1))
        
        
        case .uda:
            writeInt(&buf, Int32(2))
        
        
        case .cfa:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeAssetSchema_lift(_ buf: RustBuffer) throws -> AssetSchema {
    return try FfiConverterTypeAssetSchema.lift(buf)
}

public func FfiConverterTypeAssetSchema_lower(_ value: AssetSchema) -> RustBuffer {
    return FfiConverterTypeAssetSchema.lower(value)
}



extension AssetSchema: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum BitcoinNetwork {
    
    case mainnet
    case testnet
    case signet
    case regtest
}


public struct FfiConverterTypeBitcoinNetwork: FfiConverterRustBuffer {
    typealias SwiftType = BitcoinNetwork

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BitcoinNetwork {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .mainnet
        
        case 2: return .testnet
        
        case 3: return .signet
        
        case 4: return .regtest
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: BitcoinNetwork, into buf: inout [UInt8]) {
        switch value {
        
        
        case .mainnet:
            writeInt(&buf, Int32(1))
        
        
        case .testnet:
            writeInt(&buf, Int32(2))
        
        
        case .signet:
            writeInt(&buf, Int32(3))
        
        
        case .regtest:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeBitcoinNetwork_lift(_ buf: RustBuffer) throws -> BitcoinNetwork {
    return try FfiConverterTypeBitcoinNetwork.lift(buf)
}

public func FfiConverterTypeBitcoinNetwork_lower(_ value: BitcoinNetwork) -> RustBuffer {
    return FfiConverterTypeBitcoinNetwork.lower(value)
}



extension BitcoinNetwork: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum DatabaseType {
    
    case sqlite
}


public struct FfiConverterTypeDatabaseType: FfiConverterRustBuffer {
    typealias SwiftType = DatabaseType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DatabaseType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .sqlite
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DatabaseType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .sqlite:
            writeInt(&buf, Int32(1))
        
        }
    }
}


public func FfiConverterTypeDatabaseType_lift(_ buf: RustBuffer) throws -> DatabaseType {
    return try FfiConverterTypeDatabaseType.lift(buf)
}

public func FfiConverterTypeDatabaseType_lower(_ value: DatabaseType) -> RustBuffer {
    return FfiConverterTypeDatabaseType.lower(value)
}



extension DatabaseType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum RefreshTransferStatus {
    
    case waitingCounterparty
    case waitingConfirmations
}


public struct FfiConverterTypeRefreshTransferStatus: FfiConverterRustBuffer {
    typealias SwiftType = RefreshTransferStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RefreshTransferStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .waitingCounterparty
        
        case 2: return .waitingConfirmations
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RefreshTransferStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .waitingCounterparty:
            writeInt(&buf, Int32(1))
        
        
        case .waitingConfirmations:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeRefreshTransferStatus_lift(_ buf: RustBuffer) throws -> RefreshTransferStatus {
    return try FfiConverterTypeRefreshTransferStatus.lift(buf)
}

public func FfiConverterTypeRefreshTransferStatus_lower(_ value: RefreshTransferStatus) -> RustBuffer {
    return FfiConverterTypeRefreshTransferStatus.lower(value)
}



extension RefreshTransferStatus: Equatable, Hashable {}




public enum RgbLibError {

    
    
    case AllocationsAlreadyAvailable
    case AssetIfaceMismatch
    case AssetNotFound(assetId: String
    )
    case BatchTransferNotFound(idx: Int32
    )
    case CannotChangeOnline
    case CannotDeleteBatchTransfer
    case CannotFailBatchTransfer
    case EmptyFile(filePath: String
    )
    case FailedBdkSync(details: String
    )
    case FailedBroadcast(details: String
    )
    case FailedIssuance(details: String
    )
    case FileAlreadyExists(path: String
    )
    case Io(details: String
    )
    case Inconsistency(details: String
    )
    case Indexer(details: String
    )
    case InexistentDataDir
    case InsufficientAllocationSlots
    case InsufficientBitcoins(needed: UInt64, available: UInt64
    )
    case InsufficientSpendableAssets(assetId: String
    )
    case InsufficientTotalAssets(assetId: String
    )
    case Internal(details: String
    )
    case InvalidAddress(details: String
    )
    case InvalidAmountZero
    case InvalidAssetId(assetId: String
    )
    case InvalidAttachments(details: String
    )
    case InvalidBitcoinKeys
    case InvalidBitcoinNetwork(network: String
    )
    case InvalidDetails(details: String
    )
    case InvalidElectrum(details: String
    )
    case InvalidFeeRate(details: String
    )
    case InvalidFilePath(filePath: String
    )
    case InvalidIndexer(details: String
    )
    case InvalidInvoice(details: String
    )
    case InvalidMnemonic(details: String
    )
    case InvalidName(details: String
    )
    case InvalidPrecision(details: String
    )
    case InvalidPsbt(details: String
    )
    case InvalidPubkey(details: String
    )
    case InvalidRecipientData(details: String
    )
    case InvalidRecipientId
    case InvalidRecipientNetwork
    case InvalidScript(details: String
    )
    case InvalidTicker(details: String
    )
    case InvalidTransportEndpoint(details: String
    )
    case InvalidTransportEndpoints(details: String
    )
    case InvalidVanillaKeychain
    case MinRelayFeeNotMet(txid: String
    )
    case NoIssuanceAmounts
    case NoValidTransportEndpoint
    case Offline
    case OutputBelowDustLimit
    case Proxy(details: String
    )
    case RecipientIdAlreadyUsed
    case RecipientIdDuplicated
    case TooHighIssuanceAmounts
    case UnknownRgbInterface(interface: String
    )
    case UnknownRgbSchema(schemaId: String
    )
    case UnsupportedBackupVersion(version: String
    )
    case UnsupportedInvoice
    case UnsupportedLayer1(layer1: String
    )
    case UnsupportedTransportType
    case WatchOnly
    case WrongPassword
}


public struct FfiConverterTypeRgbLibError: FfiConverterRustBuffer {
    typealias SwiftType = RgbLibError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RgbLibError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .AllocationsAlreadyAvailable
        case 2: return .AssetIfaceMismatch
        case 3: return .AssetNotFound(
            assetId: try FfiConverterString.read(from: &buf)
            )
        case 4: return .BatchTransferNotFound(
            idx: try FfiConverterInt32.read(from: &buf)
            )
        case 5: return .CannotChangeOnline
        case 6: return .CannotDeleteBatchTransfer
        case 7: return .CannotFailBatchTransfer
        case 8: return .EmptyFile(
            filePath: try FfiConverterString.read(from: &buf)
            )
        case 9: return .FailedBdkSync(
            details: try FfiConverterString.read(from: &buf)
            )
        case 10: return .FailedBroadcast(
            details: try FfiConverterString.read(from: &buf)
            )
        case 11: return .FailedIssuance(
            details: try FfiConverterString.read(from: &buf)
            )
        case 12: return .FileAlreadyExists(
            path: try FfiConverterString.read(from: &buf)
            )
        case 13: return .Io(
            details: try FfiConverterString.read(from: &buf)
            )
        case 14: return .Inconsistency(
            details: try FfiConverterString.read(from: &buf)
            )
        case 15: return .Indexer(
            details: try FfiConverterString.read(from: &buf)
            )
        case 16: return .InexistentDataDir
        case 17: return .InsufficientAllocationSlots
        case 18: return .InsufficientBitcoins(
            needed: try FfiConverterUInt64.read(from: &buf), 
            available: try FfiConverterUInt64.read(from: &buf)
            )
        case 19: return .InsufficientSpendableAssets(
            assetId: try FfiConverterString.read(from: &buf)
            )
        case 20: return .InsufficientTotalAssets(
            assetId: try FfiConverterString.read(from: &buf)
            )
        case 21: return .Internal(
            details: try FfiConverterString.read(from: &buf)
            )
        case 22: return .InvalidAddress(
            details: try FfiConverterString.read(from: &buf)
            )
        case 23: return .InvalidAmountZero
        case 24: return .InvalidAssetId(
            assetId: try FfiConverterString.read(from: &buf)
            )
        case 25: return .InvalidAttachments(
            details: try FfiConverterString.read(from: &buf)
            )
        case 26: return .InvalidBitcoinKeys
        case 27: return .InvalidBitcoinNetwork(
            network: try FfiConverterString.read(from: &buf)
            )
        case 28: return .InvalidDetails(
            details: try FfiConverterString.read(from: &buf)
            )
        case 29: return .InvalidElectrum(
            details: try FfiConverterString.read(from: &buf)
            )
        case 30: return .InvalidFeeRate(
            details: try FfiConverterString.read(from: &buf)
            )
        case 31: return .InvalidFilePath(
            filePath: try FfiConverterString.read(from: &buf)
            )
        case 32: return .InvalidIndexer(
            details: try FfiConverterString.read(from: &buf)
            )
        case 33: return .InvalidInvoice(
            details: try FfiConverterString.read(from: &buf)
            )
        case 34: return .InvalidMnemonic(
            details: try FfiConverterString.read(from: &buf)
            )
        case 35: return .InvalidName(
            details: try FfiConverterString.read(from: &buf)
            )
        case 36: return .InvalidPrecision(
            details: try FfiConverterString.read(from: &buf)
            )
        case 37: return .InvalidPsbt(
            details: try FfiConverterString.read(from: &buf)
            )
        case 38: return .InvalidPubkey(
            details: try FfiConverterString.read(from: &buf)
            )
        case 39: return .InvalidRecipientData(
            details: try FfiConverterString.read(from: &buf)
            )
        case 40: return .InvalidRecipientId
        case 41: return .InvalidRecipientNetwork
        case 42: return .InvalidScript(
            details: try FfiConverterString.read(from: &buf)
            )
        case 43: return .InvalidTicker(
            details: try FfiConverterString.read(from: &buf)
            )
        case 44: return .InvalidTransportEndpoint(
            details: try FfiConverterString.read(from: &buf)
            )
        case 45: return .InvalidTransportEndpoints(
            details: try FfiConverterString.read(from: &buf)
            )
        case 46: return .InvalidVanillaKeychain
        case 47: return .MinRelayFeeNotMet(
            txid: try FfiConverterString.read(from: &buf)
            )
        case 48: return .NoIssuanceAmounts
        case 49: return .NoValidTransportEndpoint
        case 50: return .Offline
        case 51: return .OutputBelowDustLimit
        case 52: return .Proxy(
            details: try FfiConverterString.read(from: &buf)
            )
        case 53: return .RecipientIdAlreadyUsed
        case 54: return .RecipientIdDuplicated
        case 55: return .TooHighIssuanceAmounts
        case 56: return .UnknownRgbInterface(
            interface: try FfiConverterString.read(from: &buf)
            )
        case 57: return .UnknownRgbSchema(
            schemaId: try FfiConverterString.read(from: &buf)
            )
        case 58: return .UnsupportedBackupVersion(
            version: try FfiConverterString.read(from: &buf)
            )
        case 59: return .UnsupportedInvoice
        case 60: return .UnsupportedLayer1(
            layer1: try FfiConverterString.read(from: &buf)
            )
        case 61: return .UnsupportedTransportType
        case 62: return .WatchOnly
        case 63: return .WrongPassword

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RgbLibError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .AllocationsAlreadyAvailable:
            writeInt(&buf, Int32(1))
        
        
        case .AssetIfaceMismatch:
            writeInt(&buf, Int32(2))
        
        
        case let .AssetNotFound(assetId):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(assetId, into: &buf)
            
        
        case let .BatchTransferNotFound(idx):
            writeInt(&buf, Int32(4))
            FfiConverterInt32.write(idx, into: &buf)
            
        
        case .CannotChangeOnline:
            writeInt(&buf, Int32(5))
        
        
        case .CannotDeleteBatchTransfer:
            writeInt(&buf, Int32(6))
        
        
        case .CannotFailBatchTransfer:
            writeInt(&buf, Int32(7))
        
        
        case let .EmptyFile(filePath):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(filePath, into: &buf)
            
        
        case let .FailedBdkSync(details):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(details, into: &buf)
            
        
        case let .FailedBroadcast(details):
            writeInt(&buf, Int32(10))
            FfiConverterString.write(details, into: &buf)
            
        
        case let .FailedIssuance(details):
            writeInt(&buf, Int32(11))
            FfiConverterString.write(details, into: &buf)
            
        
        case let .FileAlreadyExists(path):
            writeInt(&buf, Int32(12))
            FfiConverterString.write(path, into: &buf)
            
        
        case let .Io(details):
            writeInt(&buf, Int32(13))
            FfiConverterString.write(details, into: &buf)
            
        
        case let .Inconsistency(details):
            writeInt(&buf, Int32(14))
            FfiConverterString.write(details, into: &buf)
            
        
        case let .Indexer(details):
            writeInt(&buf, Int32(15))
            FfiConverterString.write(details, into: &buf)
            
        
        case .InexistentDataDir:
            writeInt(&buf, Int32(16))
        
        
        case .InsufficientAllocationSlots:
            writeInt(&buf, Int32(17))
        
        
        case let .InsufficientBitcoins(needed,available):
            writeInt(&buf, Int32(18))
            FfiConverterUInt64.write(needed, into: &buf)
            FfiConverterUInt64.write(available, into: &buf)
            
        
        case let .InsufficientSpendableAssets(assetId):
            writeInt(&buf, Int32(19))
            FfiConverterString.write(assetId, into: &buf)
            
        
        case let .InsufficientTotalAssets(assetId):
            writeInt(&buf, Int32(20))
            FfiConverterString.write(assetId, into: &buf)
            
        
        case let .Internal(details):
            writeInt(&buf, Int32(21))
            FfiConverterString.write(details, into: &buf)
            
        
        case let .InvalidAddress(details):
            writeInt(&buf, Int32(22))
            FfiConverterString.write(details, into: &buf)
            
        
        case .InvalidAmountZero:
            writeInt(&buf, Int32(23))
        
        
        case let .InvalidAssetId(assetId):
            writeInt(&buf, Int32(24))
            FfiConverterString.write(assetId, into: &buf)
            
        
        case let .InvalidAttachments(details):
            writeInt(&buf, Int32(25))
            FfiConverterString.write(details, into: &buf)
            
        
        case .InvalidBitcoinKeys:
            writeInt(&buf, Int32(26))
        
        
        case let .InvalidBitcoinNetwork(network):
            writeInt(&buf, Int32(27))
            FfiConverterString.write(network, into: &buf)
            
        
        case let .InvalidDetails(details):
            writeInt(&buf, Int32(28))
            FfiConverterString.write(details, into: &buf)
            
        
        case let .InvalidElectrum(details):
            writeInt(&buf, Int32(29))
            FfiConverterString.write(details, into: &buf)
            
        
        case let .InvalidFeeRate(details):
            writeInt(&buf, Int32(30))
            FfiConverterString.write(details, into: &buf)
            
        
        case let .InvalidFilePath(filePath):
            writeInt(&buf, Int32(31))
            FfiConverterString.write(filePath, into: &buf)
            
        
        case let .InvalidIndexer(details):
            writeInt(&buf, Int32(32))
            FfiConverterString.write(details, into: &buf)
            
        
        case let .InvalidInvoice(details):
            writeInt(&buf, Int32(33))
            FfiConverterString.write(details, into: &buf)
            
        
        case let .InvalidMnemonic(details):
            writeInt(&buf, Int32(34))
            FfiConverterString.write(details, into: &buf)
            
        
        case let .InvalidName(details):
            writeInt(&buf, Int32(35))
            FfiConverterString.write(details, into: &buf)
            
        
        case let .InvalidPrecision(details):
            writeInt(&buf, Int32(36))
            FfiConverterString.write(details, into: &buf)
            
        
        case let .InvalidPsbt(details):
            writeInt(&buf, Int32(37))
            FfiConverterString.write(details, into: &buf)
            
        
        case let .InvalidPubkey(details):
            writeInt(&buf, Int32(38))
            FfiConverterString.write(details, into: &buf)
            
        
        case let .InvalidRecipientData(details):
            writeInt(&buf, Int32(39))
            FfiConverterString.write(details, into: &buf)
            
        
        case .InvalidRecipientId:
            writeInt(&buf, Int32(40))
        
        
        case .InvalidRecipientNetwork:
            writeInt(&buf, Int32(41))
        
        
        case let .InvalidScript(details):
            writeInt(&buf, Int32(42))
            FfiConverterString.write(details, into: &buf)
            
        
        case let .InvalidTicker(details):
            writeInt(&buf, Int32(43))
            FfiConverterString.write(details, into: &buf)
            
        
        case let .InvalidTransportEndpoint(details):
            writeInt(&buf, Int32(44))
            FfiConverterString.write(details, into: &buf)
            
        
        case let .InvalidTransportEndpoints(details):
            writeInt(&buf, Int32(45))
            FfiConverterString.write(details, into: &buf)
            
        
        case .InvalidVanillaKeychain:
            writeInt(&buf, Int32(46))
        
        
        case let .MinRelayFeeNotMet(txid):
            writeInt(&buf, Int32(47))
            FfiConverterString.write(txid, into: &buf)
            
        
        case .NoIssuanceAmounts:
            writeInt(&buf, Int32(48))
        
        
        case .NoValidTransportEndpoint:
            writeInt(&buf, Int32(49))
        
        
        case .Offline:
            writeInt(&buf, Int32(50))
        
        
        case .OutputBelowDustLimit:
            writeInt(&buf, Int32(51))
        
        
        case let .Proxy(details):
            writeInt(&buf, Int32(52))
            FfiConverterString.write(details, into: &buf)
            
        
        case .RecipientIdAlreadyUsed:
            writeInt(&buf, Int32(53))
        
        
        case .RecipientIdDuplicated:
            writeInt(&buf, Int32(54))
        
        
        case .TooHighIssuanceAmounts:
            writeInt(&buf, Int32(55))
        
        
        case let .UnknownRgbInterface(interface):
            writeInt(&buf, Int32(56))
            FfiConverterString.write(interface, into: &buf)
            
        
        case let .UnknownRgbSchema(schemaId):
            writeInt(&buf, Int32(57))
            FfiConverterString.write(schemaId, into: &buf)
            
        
        case let .UnsupportedBackupVersion(version):
            writeInt(&buf, Int32(58))
            FfiConverterString.write(version, into: &buf)
            
        
        case .UnsupportedInvoice:
            writeInt(&buf, Int32(59))
        
        
        case let .UnsupportedLayer1(layer1):
            writeInt(&buf, Int32(60))
            FfiConverterString.write(layer1, into: &buf)
            
        
        case .UnsupportedTransportType:
            writeInt(&buf, Int32(61))
        
        
        case .WatchOnly:
            writeInt(&buf, Int32(62))
        
        
        case .WrongPassword:
            writeInt(&buf, Int32(63))
        
        }
    }
}


extension RgbLibError: Equatable, Hashable {}

extension RgbLibError: Error { }

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum TransactionType {
    
    case rgbSend
    case drain
    case createUtxos
    case user
}


public struct FfiConverterTypeTransactionType: FfiConverterRustBuffer {
    typealias SwiftType = TransactionType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .rgbSend
        
        case 2: return .drain
        
        case 3: return .createUtxos
        
        case 4: return .user
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TransactionType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .rgbSend:
            writeInt(&buf, Int32(1))
        
        
        case .drain:
            writeInt(&buf, Int32(2))
        
        
        case .createUtxos:
            writeInt(&buf, Int32(3))
        
        
        case .user:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeTransactionType_lift(_ buf: RustBuffer) throws -> TransactionType {
    return try FfiConverterTypeTransactionType.lift(buf)
}

public func FfiConverterTypeTransactionType_lower(_ value: TransactionType) -> RustBuffer {
    return FfiConverterTypeTransactionType.lower(value)
}



extension TransactionType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum TransferKind {
    
    case issuance
    case receiveBlind
    case receiveWitness
    case send
}


public struct FfiConverterTypeTransferKind: FfiConverterRustBuffer {
    typealias SwiftType = TransferKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransferKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .issuance
        
        case 2: return .receiveBlind
        
        case 3: return .receiveWitness
        
        case 4: return .send
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TransferKind, into buf: inout [UInt8]) {
        switch value {
        
        
        case .issuance:
            writeInt(&buf, Int32(1))
        
        
        case .receiveBlind:
            writeInt(&buf, Int32(2))
        
        
        case .receiveWitness:
            writeInt(&buf, Int32(3))
        
        
        case .send:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeTransferKind_lift(_ buf: RustBuffer) throws -> TransferKind {
    return try FfiConverterTypeTransferKind.lift(buf)
}

public func FfiConverterTypeTransferKind_lower(_ value: TransferKind) -> RustBuffer {
    return FfiConverterTypeTransferKind.lower(value)
}



extension TransferKind: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum TransferStatus {
    
    case waitingCounterparty
    case waitingConfirmations
    case settled
    case failed
}


public struct FfiConverterTypeTransferStatus: FfiConverterRustBuffer {
    typealias SwiftType = TransferStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransferStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .waitingCounterparty
        
        case 2: return .waitingConfirmations
        
        case 3: return .settled
        
        case 4: return .failed
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TransferStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .waitingCounterparty:
            writeInt(&buf, Int32(1))
        
        
        case .waitingConfirmations:
            writeInt(&buf, Int32(2))
        
        
        case .settled:
            writeInt(&buf, Int32(3))
        
        
        case .failed:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeTransferStatus_lift(_ buf: RustBuffer) throws -> TransferStatus {
    return try FfiConverterTypeTransferStatus.lift(buf)
}

public func FfiConverterTypeTransferStatus_lower(_ value: TransferStatus) -> RustBuffer {
    return FfiConverterTypeTransferStatus.lower(value)
}



extension TransferStatus: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum TransportType {
    
    case jsonRpc
}


public struct FfiConverterTypeTransportType: FfiConverterRustBuffer {
    typealias SwiftType = TransportType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransportType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .jsonRpc
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TransportType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .jsonRpc:
            writeInt(&buf, Int32(1))
        
        }
    }
}


public func FfiConverterTypeTransportType_lift(_ buf: RustBuffer) throws -> TransportType {
    return try FfiConverterTypeTransportType.lift(buf)
}

public func FfiConverterTypeTransportType_lower(_ value: TransportType) -> RustBuffer {
    return FfiConverterTypeTransportType.lower(value)
}



extension TransportType: Equatable, Hashable {}



fileprivate struct FfiConverterOptionUInt8: FfiConverterRustBuffer {
    typealias SwiftType = UInt8?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt8.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt8.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionUInt32: FfiConverterRustBuffer {
    typealias SwiftType = UInt32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionInt32: FfiConverterRustBuffer {
    typealias SwiftType = Int32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionUInt64: FfiConverterRustBuffer {
    typealias SwiftType = UInt64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionInt64: FfiConverterRustBuffer {
    typealias SwiftType = Int64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeBlockTime: FfiConverterRustBuffer {
    typealias SwiftType = BlockTime?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeBlockTime.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeBlockTime.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeEmbeddedMedia: FfiConverterRustBuffer {
    typealias SwiftType = EmbeddedMedia?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeEmbeddedMedia.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeEmbeddedMedia.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeMedia: FfiConverterRustBuffer {
    typealias SwiftType = Media?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMedia.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMedia.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeOnline: FfiConverterRustBuffer {
    typealias SwiftType = Online?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeOnline.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeOnline.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeOutpoint: FfiConverterRustBuffer {
    typealias SwiftType = Outpoint?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeOutpoint.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeOutpoint.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeProofOfReserves: FfiConverterRustBuffer {
    typealias SwiftType = ProofOfReserves?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeProofOfReserves.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeProofOfReserves.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeToken: FfiConverterRustBuffer {
    typealias SwiftType = Token?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeToken.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeToken.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeTokenLight: FfiConverterRustBuffer {
    typealias SwiftType = TokenLight?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeTokenLight.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeTokenLight.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeWitnessData: FfiConverterRustBuffer {
    typealias SwiftType = WitnessData?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeWitnessData.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeWitnessData.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeAssetIface: FfiConverterRustBuffer {
    typealias SwiftType = AssetIface?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAssetIface.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAssetIface.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeRgbLibError: FfiConverterRustBuffer {
    typealias SwiftType = RgbLibError?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeRgbLibError.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRgbLibError.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeTransferStatus: FfiConverterRustBuffer {
    typealias SwiftType = TransferStatus?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeTransferStatus.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeTransferStatus.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypeAssetCFA: FfiConverterRustBuffer {
    typealias SwiftType = [AssetCfa]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeAssetCFA.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeAssetCFA.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypeAssetNIA: FfiConverterRustBuffer {
    typealias SwiftType = [AssetNia]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeAssetNIA.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeAssetNIA.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypeAssetUDA: FfiConverterRustBuffer {
    typealias SwiftType = [AssetUda]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeAssetUDA.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeAssetUDA.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterSequenceUInt8: FfiConverterRustBuffer {
    typealias SwiftType = [UInt8]

    public static func write(_ value: [UInt8], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt8.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt8] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt8]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterUInt8.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceUInt64: FfiConverterRustBuffer {
    typealias SwiftType = [UInt64]

    public static func write(_ value: [UInt64], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt64.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt64] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt64]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterUInt64.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeAssetCFA: FfiConverterRustBuffer {
    typealias SwiftType = [AssetCfa]

    public static func write(_ value: [AssetCfa], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAssetCFA.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AssetCfa] {
        let len: Int32 = try readInt(&buf)
        var seq = [AssetCfa]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAssetCFA.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeAssetNIA: FfiConverterRustBuffer {
    typealias SwiftType = [AssetNia]

    public static func write(_ value: [AssetNia], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAssetNIA.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AssetNia] {
        let len: Int32 = try readInt(&buf)
        var seq = [AssetNia]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAssetNIA.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeAssetUDA: FfiConverterRustBuffer {
    typealias SwiftType = [AssetUda]

    public static func write(_ value: [AssetUda], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAssetUDA.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AssetUda] {
        let len: Int32 = try readInt(&buf)
        var seq = [AssetUda]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAssetUDA.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeRecipient: FfiConverterRustBuffer {
    typealias SwiftType = [Recipient]

    public static func write(_ value: [Recipient], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRecipient.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Recipient] {
        let len: Int32 = try readInt(&buf)
        var seq = [Recipient]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRecipient.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeRefreshFilter: FfiConverterRustBuffer {
    typealias SwiftType = [RefreshFilter]

    public static func write(_ value: [RefreshFilter], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRefreshFilter.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RefreshFilter] {
        let len: Int32 = try readInt(&buf)
        var seq = [RefreshFilter]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRefreshFilter.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeRgbAllocation: FfiConverterRustBuffer {
    typealias SwiftType = [RgbAllocation]

    public static func write(_ value: [RgbAllocation], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRgbAllocation.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RgbAllocation] {
        let len: Int32 = try readInt(&buf)
        var seq = [RgbAllocation]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRgbAllocation.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeTransaction: FfiConverterRustBuffer {
    typealias SwiftType = [Transaction]

    public static func write(_ value: [Transaction], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTransaction.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Transaction] {
        let len: Int32 = try readInt(&buf)
        var seq = [Transaction]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTransaction.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeTransfer: FfiConverterRustBuffer {
    typealias SwiftType = [Transfer]

    public static func write(_ value: [Transfer], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTransfer.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Transfer] {
        let len: Int32 = try readInt(&buf)
        var seq = [Transfer]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTransfer.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeTransferTransportEndpoint: FfiConverterRustBuffer {
    typealias SwiftType = [TransferTransportEndpoint]

    public static func write(_ value: [TransferTransportEndpoint], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTransferTransportEndpoint.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TransferTransportEndpoint] {
        let len: Int32 = try readInt(&buf)
        var seq = [TransferTransportEndpoint]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTransferTransportEndpoint.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeUnspent: FfiConverterRustBuffer {
    typealias SwiftType = [Unspent]

    public static func write(_ value: [Unspent], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeUnspent.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Unspent] {
        let len: Int32 = try readInt(&buf)
        var seq = [Unspent]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeUnspent.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeAssetSchema: FfiConverterRustBuffer {
    typealias SwiftType = [AssetSchema]

    public static func write(_ value: [AssetSchema], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAssetSchema.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AssetSchema] {
        let len: Int32 = try readInt(&buf)
        var seq = [AssetSchema]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAssetSchema.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterDictionaryUInt8TypeMedia: FfiConverterRustBuffer {
    public static func write(_ value: [UInt8: Media], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterUInt8.write(key, into: &buf)
            FfiConverterTypeMedia.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt8: Media] {
        let len: Int32 = try readInt(&buf)
        var dict = [UInt8: Media]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterUInt8.read(from: &buf)
            let value = try FfiConverterTypeMedia.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryInt32TypeRefreshedTransfer: FfiConverterRustBuffer {
    public static func write(_ value: [Int32: RefreshedTransfer], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterInt32.write(key, into: &buf)
            FfiConverterTypeRefreshedTransfer.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Int32: RefreshedTransfer] {
        let len: Int32 = try readInt(&buf)
        var dict = [Int32: RefreshedTransfer]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterInt32.read(from: &buf)
            let value = try FfiConverterTypeRefreshedTransfer.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringSequenceTypeRecipient: FfiConverterRustBuffer {
    public static func write(_ value: [String: [Recipient]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterSequenceTypeRecipient.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: [Recipient]] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: [Recipient]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterSequenceTypeRecipient.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}
public func generateKeys(bitcoinNetwork: BitcoinNetwork) -> Keys {
    return try!  FfiConverterTypeKeys.lift(try! rustCall() {
    uniffi_rgblibffi_fn_func_generate_keys(
        FfiConverterTypeBitcoinNetwork.lower(bitcoinNetwork),$0
    )
})
}
public func restoreBackup(backupPath: String, password: String, dataDir: String)throws  {try rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgblibffi_fn_func_restore_backup(
        FfiConverterString.lower(backupPath),
        FfiConverterString.lower(password),
        FfiConverterString.lower(dataDir),$0
    )
}
}
public func restoreKeys(bitcoinNetwork: BitcoinNetwork, mnemonic: String)throws  -> Keys {
    return try  FfiConverterTypeKeys.lift(try rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgblibffi_fn_func_restore_keys(
        FfiConverterTypeBitcoinNetwork.lower(bitcoinNetwork),
        FfiConverterString.lower(mnemonic),$0
    )
})
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variables to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 26
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_rgblibffi_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_rgblibffi_checksum_func_generate_keys() != 64259) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgblibffi_checksum_func_restore_backup() != 15101) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgblibffi_checksum_func_restore_keys() != 42405) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgblibffi_checksum_method_invoice_invoice_data() != 11706) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgblibffi_checksum_method_invoice_invoice_string() != 49576) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgblibffi_checksum_method_transportendpoint_transport_type() != 52347) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgblibffi_checksum_method_wallet_backup() != 60293) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgblibffi_checksum_method_wallet_backup_info() != 938) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgblibffi_checksum_method_wallet_blind_receive() != 34365) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgblibffi_checksum_method_wallet_create_utxos() != 59455) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgblibffi_checksum_method_wallet_create_utxos_begin() != 58076) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgblibffi_checksum_method_wallet_create_utxos_end() != 37296) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgblibffi_checksum_method_wallet_delete_transfers() != 55560) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgblibffi_checksum_method_wallet_drain_to() != 28781) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgblibffi_checksum_method_wallet_drain_to_begin() != 37910) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgblibffi_checksum_method_wallet_drain_to_end() != 19119) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgblibffi_checksum_method_wallet_fail_transfers() != 24813) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgblibffi_checksum_method_wallet_get_address() != 51506) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgblibffi_checksum_method_wallet_get_asset_balance() != 34628) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgblibffi_checksum_method_wallet_get_asset_metadata() != 33881) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgblibffi_checksum_method_wallet_get_btc_balance() != 29947) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgblibffi_checksum_method_wallet_go_online() != 36143) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgblibffi_checksum_method_wallet_issue_asset_cfa() != 10376) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgblibffi_checksum_method_wallet_issue_asset_nia() != 17069) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgblibffi_checksum_method_wallet_issue_asset_uda() != 56590) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgblibffi_checksum_method_wallet_list_assets() != 46965) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgblibffi_checksum_method_wallet_list_transactions() != 56257) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgblibffi_checksum_method_wallet_list_transfers() != 36467) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgblibffi_checksum_method_wallet_list_unspents() != 4224) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgblibffi_checksum_method_wallet_refresh() != 41719) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgblibffi_checksum_method_wallet_send() != 54460) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgblibffi_checksum_method_wallet_send_begin() != 21520) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgblibffi_checksum_method_wallet_send_btc() != 47940) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgblibffi_checksum_method_wallet_send_btc_begin() != 31034) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgblibffi_checksum_method_wallet_send_btc_end() != 58866) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgblibffi_checksum_method_wallet_send_end() != 34331) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgblibffi_checksum_method_wallet_sign_psbt() != 29982) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgblibffi_checksum_method_wallet_witness_receive() != 47965) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgblibffi_checksum_constructor_invoice_from_invoice_data() != 43541) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgblibffi_checksum_constructor_invoice_new() != 56538) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgblibffi_checksum_constructor_recipientinfo_new() != 42681) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgblibffi_checksum_constructor_transportendpoint_new() != 1325) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgblibffi_checksum_constructor_wallet_new() != 55128) {
        return InitializationResult.apiChecksumMismatch
    }

    return InitializationResult.ok
}

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all